{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Dataclasses JSON This library provides a simple API for encoding and decoding dataclasses to and from JSON. It's very easy to get started. README / Documentation website . Features a navigation bar and search functionality, and should mirror this README exactly -- take a look! Quickstart pip install dataclasses-json from dataclasses import dataclass from dataclasses_json import dataclass_json @dataclass_json @dataclass class Person : name : str person = Person ( name = 'lidatong' ) person . to_json () # '{\"name\": \"lidatong\"}' <- this is a string person . to_dict () # {'name': 'lidatong'} <- this is a dict Person . from_json ( '{\"name\": \"lidatong\"}' ) # Person(1) Person . from_dict ({ 'name' : 'lidatong' }) # Person(1) # You can also apply _schema validation_ using an alternative API # This can be useful for \"typed\" Python code Person . from_json ( '{\"name\": 42}' ) # This is ok. 42 is not a `str`, but # dataclass creation does not validate types Person . schema () . loads ( '{\"name\": 42}' ) # Error! Raises `ValidationError` What if you want to work with camelCase JSON? # same imports as above, with the additional `LetterCase` import from dataclasses import dataclass from dataclasses_json import dataclass_json , LetterCase @dataclass_json ( letter_case = LetterCase . CAMEL ) # now all fields are encoded/decoded from camelCase @dataclass class ConfiguredSimpleExample : int_field : int ConfiguredSimpleExample ( 1 ) . to_json () # {\"intField\": 1} ConfiguredSimpleExample . from_json ( '{\"intField\": 1}' ) # ConfiguredSimpleExample(1) Supported types It's recursive (see caveats below), so you can easily work with nested dataclasses. In addition to the supported types in the py to JSON table , this library supports the following: any arbitrary Collection type is supported. Mapping types are encoded as JSON objects and str types as JSON strings. Any other Collection types are encoded into JSON arrays, but decoded into the original collection types. datetime objects. datetime objects are encoded to float (JSON number) using timestamp . As specified in the datetime docs, if your datetime object is naive, it will assume your system local timezone when calling .timestamp() . JSON numbers corresponding to a datetime field in your dataclass are decoded into a datetime-aware object, with tzinfo set to your system local timezone. Thus, if you encode a datetime-naive object, you will decode into a datetime-aware object. This is important, because encoding and decoding won't strictly be inverses. See this section if you want to override this default behavior (for example, if you want to use ISO). UUID objects. They are encoded as str (JSON string). Decimal objects. They are also encoded as str . The latest release is compatible with both Python 3.7 and Python 3.6 (with the dataclasses backport). Usage Approach 1: Class decorator from dataclasses import dataclass from dataclasses_json import dataclass_json @dataclass_json @dataclass class Person : name : str lidatong = Person ( 'lidatong' ) # Encoding to JSON lidatong . to_json () # '{\"name\": \"lidatong\"}' # Decoding from JSON Person . from_json ( '{\"name\": \"lidatong\"}' ) # Person(name='lidatong') Note that the @dataclass_json decorator must be stacked above the @dataclass decorator (order matters!) Approach 2: Inherit from a mixin from dataclasses import dataclass from dataclasses_json import DataClassJsonMixin @dataclass class Person ( DataClassJsonMixin ): name : str lidatong = Person ( 'lidatong' ) # A different example from Approach 1 above, but usage is the exact same assert Person . from_json ( lidatong . to_json ()) == lidatong Pick whichever approach suits your taste. Note that there is better support for the mixin approach when using static analysis tools (e.g. linting, typing), but the differences in implementation will be invisible in runtime usage. How do I... Use my dataclass with JSON arrays or objects? from dataclasses import dataclass from dataclasses_json import dataclass_json @dataclass_json @dataclass class Person : name : str Encode into a JSON array containing instances of my Data Class people_json = [ Person ( 'lidatong' )] Person . schema () . dumps ( people_json , many = True ) # '[{\"name\": \"lidatong\"}]' Decode a JSON array containing instances of my Data Class people_json = '[{\"name\": \"lidatong\"}]' Person . schema () . loads ( people_json , many = True ) # [Person(name='lidatong')] Encode as part of a larger JSON object containing my Data Class (e.g. an HTTP request/response) import json response_dict = { 'response' : { 'person' : Person ( 'lidatong' ) . to_dict () } } response_json = json . dumps ( response_dict ) In this case, we do two steps. First, we encode the dataclass into a python dictionary rather than a JSON string, using .to_dict . Second, we leverage the built-in json.dumps to serialize our dataclass into a JSON string. Decode as part of a larger JSON object containing my Data Class (e.g. an HTTP response) import json response_dict = json . loads ( '{\"response\": {\"person\": {\"name\": \"lidatong\"}}}' ) person_dict = response_dict [ 'response' ] person = Person . from_dict ( person_dict ) In a similar vein to encoding above, we leverage the built-in json module. First, call json.loads to read the entire JSON object into a dictionary. We then access the key of the value containing the encoded dict of our Person that we want to decode ( response_dict['response'] ). Second, we load in the dictionary using Person.from_dict . Encode or decode into Python lists/dictionaries rather than JSON? This can be by calling .schema() and then using the corresponding encoder/decoder methods, ie. .load(...) / .dump(...) . Encode into a single Python dictionary person = Person ( 'lidatong' ) person . to_dict () # {'name': 'lidatong'} Encode into a list of Python dictionaries people = [ Person ( 'lidatong' )] Person . schema () . dump ( people , many = True ) # [{'name': 'lidatong'}] Decode a dictionary into a single dataclass instance person_dict = { 'name' : 'lidatong' } Person . from_dict ( person_dict ) # Person(name='lidatong') Decode a list of dictionaries into a list of dataclass instances people_dicts = [{ \"name\" : \"lidatong\" }] Person . schema () . load ( people_dicts , many = True ) # [Person(name='lidatong')] Encode or decode from camelCase (or kebab-case)? JSON letter case by convention is camelCase, in Python members are by convention snake_case. You can configure it to encode/decode from other casing schemes at both the class level and the field level. from dataclasses import dataclass , field from dataclasses_json import LetterCase , config , dataclass_json # changing casing at the class level @dataclass_json ( letter_case = LetterCase . CAMEL ) @dataclass class Person : given_name : str family_name : str Person ( 'Alice' , 'Liddell' ) . to_json () # '{\"givenName\": \"Alice\"}' Person . from_json ( '{\"givenName\": \"Alice\", \"familyName\": \"Liddell\"}' ) # Person('Alice', 'Liddell') # at the field level @dataclass_json @dataclass class Person : given_name : str = field ( metadata = config ( letter_case = LetterCase . CAMEL )) family_name : str Person ( 'Alice' , 'Liddell' ) . to_json () # '{\"givenName\": \"Alice\"}' # notice how the `family_name` field is still snake_case, because it wasn't configured above Person . from_json ( '{\"givenName\": \"Alice\", \"family_name\": \"Liddell\"}' ) # Person('Alice', 'Liddell') This library assumes your field follows the Python convention of snake_case naming. If your field is not snake_case to begin with and you attempt to parameterize LetterCase , the behavior of encoding/decoding is undefined (most likely it will result in subtle bugs). Encode or decode using a different name from dataclasses import dataclass , field from dataclasses_json import config , dataclass_json @dataclass_json @dataclass class Person : given_name : str = field ( metadata = config ( field_name = \"overriddenGivenName\" )) Person ( given_name = \"Alice\" ) # Person('Alice') Person . from_json ( '{\"overriddenGivenName\": \"Alice\"}' ) # Person('Alice') Person ( 'Alice' ) . to_json () # {\"overriddenGivenName\": \"Alice\"} Handle missing or optional field values when decoding? By default, any fields in your dataclass that use default or default_factory will have the values filled with the provided default, if the corresponding field is missing from the JSON you're decoding. Decode JSON with missing field @dataclass_json @dataclass class Student : id : int name : str = 'student' Student . from_json ( '{\"id\": 1}' ) # Student(id=1, name='student') Notice from_json filled the field name with the specified default 'student' when it was missing from the JSON. Sometimes you have fields that are typed as Optional , but you don't necessarily want to assign a default. In that case, you can use the infer_missing kwarg to make from_json infer the missing field value as None . Decode optional field without default @dataclass_json @dataclass class Tutor : id : int student : Optional [ Student ] = None Tutor . from_json ( '{\"id\": 1}' ) # Tutor(id=1, student=None) Personally I recommend you leverage dataclass defaults rather than using infer_missing , but if for some reason you need to decouple the behavior of JSON decoding from the field's default value, this will allow you to do so. Handle unknown / extraneous fields in JSON? By default, it is up to the implementation what happens when a json_dataclass receives input parameters that are not defined. (the from_dict method ignores them, when loading using schema() a ValidationError is raised.) There are three ways to customize this behavior. Assume you want to instantiate a dataclass with the following dictionary: dump_dict = { \"endpoint\" : \"some_api_endpoint\" , \"data\" : { \"foo\" : 1 , \"bar\" : \"2\" }, \"undefined_field_name\" : [ 1 , 2 , 3 ]} You can enforce to always raise an error by setting the undefined keyword to Undefined.RAISE ( 'RAISE' as a case-insensitive string works as well). Of course it works normally if you don't pass any undefined parameters. from dataclasses_json import Undefined @dataclass_json ( undefined = Undefined . RAISE ) @dataclass () class ExactAPIDump : endpoint : str data : Dict [ str , Any ] dump = ExactAPIDump . from_dict ( dump_dict ) # raises UndefinedParameterError You can simply ignore any undefined parameters by setting the undefined keyword to Undefined.EXCLUDE ( 'EXCLUDE' as a case-insensitive string works as well). Note that you will not be able to retrieve them using to_dict : from dataclasses_json import Undefined @dataclass_json ( undefined = Undefined . EXCLUDE ) @dataclass () class DontCareAPIDump : endpoint : str data : Dict [ str , Any ] dump = DontCareAPIDump . from_dict ( dump_dict ) # DontCareAPIDump(endpoint='some_api_endpoint', data={'foo': 1, 'bar': '2'}) dump . to_dict () # {\"endpoint\": \"some_api_endpoint\", \"data\": {\"foo\": 1, \"bar\": \"2\"}} You can save them in a catch-all field and do whatever needs to be done later. Simply set the undefined keyword to Undefined.INCLUDE ( 'INCLUDE' as a case-insensitive string works as well) and define a field of type CatchAll where all unknown values will end up. This simply represents a dictionary that can hold anything. If there are no undefined parameters, this will be an empty dictionary. from dataclasses_json import Undefined , CatchAll @dataclass_json ( undefined = Undefined . INCLUDE ) @dataclass () class UnknownAPIDump : endpoint : str data : Dict [ str , Any ] unknown_things : CatchAll dump = UnknownAPIDump . from_dict ( dump_dict ) # UnknownAPIDump(endpoint='some_api_endpoint', data={'foo': 1, 'bar': '2'}, unknown_things={'undefined_field_name': [1, 2, 3]}) dump . to_dict () # {'endpoint': 'some_api_endpoint', 'data': {'foo': 1, 'bar': '2'}, 'undefined_field_name': [1, 2, 3]} Notes: - When using Undefined.INCLUDE , an UndefinedParameterError will be raised if you don't specify exactly one field of type CatchAll . - Note that LetterCase does not affect values written into the CatchAll field, they will be as they are given. - When specifying a default (or a default factory) for the the CatchAll -field, e.g. unknown_things: CatchAll = None , the default value will be used instead of an empty dict if there are no undefined parameters. - Calling init with non-keyword arguments resolves the arguments to the defined fields and writes everything else into the catch-all field. All 3 options work as well using schema().loads and schema().dumps , as long as you don't overwrite it by specifying schema(unknown=<a marshmallow value>) . marshmallow uses the same 3 keywords 'include', 'exclude', 'raise' . All 3 operations work as well using __init__ , e.g. UnknownAPIDump(**dump_dict) will not raise a TypeError , but write all unknown values to the field tagged as CatchAll . Classes tagged with EXCLUDE will also simply ignore unknown parameters. Note that classes tagged as RAISE still raise a TypeError , and not a UndefinedParameterError if supplied with unknown keywords. Override the default encode / decode / marshmallow field of a specific field? See Overriding Handle recursive dataclasses? Object hierarchies where fields are of the type that they are declared within require a small type hinting trick to declare the forward reference. from typing import Optional from dataclasses import dataclass from dataclasses_json import dataclass_json @dataclass_json @dataclass class Tree (): value : str left : Optional [ 'Tree' ] right : Optional [ 'Tree' ] Avoid using from __future__ import annotations as it will cause problems with the way dataclasses_json accesses the type annotations. Marshmallow interop Using the dataclass_json decorator or mixing in DataClassJsonMixin will provide you with an additional method .schema() . .schema() generates a schema exactly equivalent to manually creating a marshmallow schema for your dataclass. You can reference the marshmallow API docs to learn other ways you can use the schema returned by .schema() . You can pass in the exact same arguments to .schema() that you would when constructing a PersonSchema instance, e.g. .schema(many=True) , and they will get passed through to the marshmallow schema. from dataclasses import dataclass from dataclasses_json import dataclass_json @dataclass_json @dataclass class Person : name : str # You don't need to do this - it's generated for you by `.schema()`! from marshmallow import Schema , fields class PersonSchema ( Schema ): name = fields . Str () Briefly, on what's going on under the hood in the above examples: calling .schema() will have this library generate a marshmallow schema for you. It also fills in the corresponding object hook, so that marshmallow will create an instance of your Data Class on load (e.g. Person.schema().load returns a Person ) rather than a dict , which it does by default in marshmallow. Performance note .schema() is not cached (it generates the schema on every call), so if you have a nested Data Class you may want to save the result to a variable to avoid re-generation of the schema on every usage. person_schema = Person . schema () person_schema . dump ( people , many = True ) # later in the code... person_schema . dump ( person ) Overriding / Extending Overriding For example, you might want to encode/decode datetime objects using ISO format rather than the default timestamp . from dataclasses import dataclass , field from dataclasses_json import dataclass_json , config from datetime import datetime from marshmallow import fields @dataclass_json @dataclass class DataClassWithIsoDatetime : created_at : datetime = field ( metadata = config ( encoder = datetime . isoformat , decoder = datetime . fromisoformat , mm_field = fields . DateTime ( format = 'iso' ) ) ) Extending Similarly, you might want to extend dataclasses_json to encode date objects. from dataclasses import dataclass , field from dataclasses_json import dataclass_json , config from datetime import date from marshmallow import fields @dataclass_json @dataclass class DataClassWithIsoDatetime : created_at : date = field ( metadata = config ( encoder = date . isoformat , decoder = date . fromisoformat , mm_field = fields . DateTime ( format = 'iso' ) )) As you can see, you can override or extend the default codecs by providing a \"hook\" via a callable: - encoder : a callable, which will be invoked to convert the field value when encoding to JSON - decoder : a callable, which will be invoked to convert the JSON value when decoding from JSON - mm_field : a marshmallow field, which will affect the behavior of any operations involving .schema() Note that these hooks will be invoked regardless if you're using .to_json / dump / dumps and .from_json / load / loads . So apply overrides / extensions judiciously, making sure to carefully consider whether the interaction of the encode/decode/mm_field is consistent with what you expect! What if I have other dataclass field extensions that rely on metadata All the dataclasses_json.config does is return a mapping, namespaced under the key 'dataclasses_json' . Say there's another module, other_dataclass_package that uses metadata. Here's how you solve your problem: metadata = { 'other_dataclass_package' : 'some metadata...' } # pre-existing metadata for another dataclass package dataclass_json_config = config ( encoder = datetime . isoformat , decoder = datetime . fromisoformat , mm_field = fields . DateTime ( format = 'iso' ) ) metadata . update ( dataclass_json_config ) @dataclass_json @dataclass class DataClassWithIsoDatetime : created_at : datetime = field ( metadata = metadata ) You can also manually specify the dataclass_json configuration mapping. @dataclass_json @dataclass class DataClassWithIsoDatetime : created_at : date = field ( metadata = { 'dataclasses_json' : { 'encoder' : date . isoformat , 'decoder' : date . fromisoformat , 'mm_field' : fields . DateTime ( format = 'iso' ) }} ) A larger example from dataclasses import dataclass from dataclasses_json import dataclass_json from typing import List @dataclass_json @dataclass ( frozen = True ) class Minion : name : str @dataclass_json @dataclass ( frozen = True ) class Boss : minions : List [ Minion ] boss = Boss ([ Minion ( 'evil minion' ), Minion ( 'very evil minion' )]) boss_json = \"\"\" { \"minions\": [ { \"name\": \"evil minion\" }, { \"name\": \"very evil minion\" } ] } \"\"\" . strip () assert boss . to_json ( indent = 4 ) == boss_json assert Boss . from_json ( boss_json ) == boss Performance Take a look at this issue Versioning Note this library is still pre-1.0.0 (SEMVER). The current convention is: - PATCH version upgrades for bug fixes and minor feature additions. - MINOR version upgrades for big API features and breaking changes. Once this library is 1.0.0, it will follow standard SEMVER conventions. Roadmap Currently the focus is on investigating and fixing bugs in this library, working on performance, and finishing this issue . That said, if you think there's a feature missing / something new needed in the library, please see the contributing section below. Contributing First of all, thank you for being interested in contributing to this library. I really appreciate you taking the time to work on this project. If you're just interested in getting into the code, a good place to start are issues tagged as bugs. If introducing a new feature, especially one that modifies the public API, consider submitting an issue for discussion before a PR. Please also take a look at existing issues / PRs to see what you're proposing has already been covered before / exists. I like to follow the commit conventions documented here","title":"Home"},{"location":"#dataclasses-json","text":"This library provides a simple API for encoding and decoding dataclasses to and from JSON. It's very easy to get started. README / Documentation website . Features a navigation bar and search functionality, and should mirror this README exactly -- take a look!","title":"Dataclasses JSON"},{"location":"#quickstart","text":"pip install dataclasses-json from dataclasses import dataclass from dataclasses_json import dataclass_json @dataclass_json @dataclass class Person : name : str person = Person ( name = 'lidatong' ) person . to_json () # '{\"name\": \"lidatong\"}' <- this is a string person . to_dict () # {'name': 'lidatong'} <- this is a dict Person . from_json ( '{\"name\": \"lidatong\"}' ) # Person(1) Person . from_dict ({ 'name' : 'lidatong' }) # Person(1) # You can also apply _schema validation_ using an alternative API # This can be useful for \"typed\" Python code Person . from_json ( '{\"name\": 42}' ) # This is ok. 42 is not a `str`, but # dataclass creation does not validate types Person . schema () . loads ( '{\"name\": 42}' ) # Error! Raises `ValidationError` What if you want to work with camelCase JSON? # same imports as above, with the additional `LetterCase` import from dataclasses import dataclass from dataclasses_json import dataclass_json , LetterCase @dataclass_json ( letter_case = LetterCase . CAMEL ) # now all fields are encoded/decoded from camelCase @dataclass class ConfiguredSimpleExample : int_field : int ConfiguredSimpleExample ( 1 ) . to_json () # {\"intField\": 1} ConfiguredSimpleExample . from_json ( '{\"intField\": 1}' ) # ConfiguredSimpleExample(1)","title":"Quickstart"},{"location":"#supported-types","text":"It's recursive (see caveats below), so you can easily work with nested dataclasses. In addition to the supported types in the py to JSON table , this library supports the following: any arbitrary Collection type is supported. Mapping types are encoded as JSON objects and str types as JSON strings. Any other Collection types are encoded into JSON arrays, but decoded into the original collection types. datetime objects. datetime objects are encoded to float (JSON number) using timestamp . As specified in the datetime docs, if your datetime object is naive, it will assume your system local timezone when calling .timestamp() . JSON numbers corresponding to a datetime field in your dataclass are decoded into a datetime-aware object, with tzinfo set to your system local timezone. Thus, if you encode a datetime-naive object, you will decode into a datetime-aware object. This is important, because encoding and decoding won't strictly be inverses. See this section if you want to override this default behavior (for example, if you want to use ISO). UUID objects. They are encoded as str (JSON string). Decimal objects. They are also encoded as str . The latest release is compatible with both Python 3.7 and Python 3.6 (with the dataclasses backport).","title":"Supported types"},{"location":"#usage","text":"","title":"Usage"},{"location":"#approach-1-class-decorator","text":"from dataclasses import dataclass from dataclasses_json import dataclass_json @dataclass_json @dataclass class Person : name : str lidatong = Person ( 'lidatong' ) # Encoding to JSON lidatong . to_json () # '{\"name\": \"lidatong\"}' # Decoding from JSON Person . from_json ( '{\"name\": \"lidatong\"}' ) # Person(name='lidatong') Note that the @dataclass_json decorator must be stacked above the @dataclass decorator (order matters!)","title":"Approach 1: Class decorator"},{"location":"#approach-2-inherit-from-a-mixin","text":"from dataclasses import dataclass from dataclasses_json import DataClassJsonMixin @dataclass class Person ( DataClassJsonMixin ): name : str lidatong = Person ( 'lidatong' ) # A different example from Approach 1 above, but usage is the exact same assert Person . from_json ( lidatong . to_json ()) == lidatong Pick whichever approach suits your taste. Note that there is better support for the mixin approach when using static analysis tools (e.g. linting, typing), but the differences in implementation will be invisible in runtime usage.","title":"Approach 2: Inherit from a mixin"},{"location":"#how-do-i","text":"","title":"How do I..."},{"location":"#use-my-dataclass-with-json-arrays-or-objects","text":"from dataclasses import dataclass from dataclasses_json import dataclass_json @dataclass_json @dataclass class Person : name : str Encode into a JSON array containing instances of my Data Class people_json = [ Person ( 'lidatong' )] Person . schema () . dumps ( people_json , many = True ) # '[{\"name\": \"lidatong\"}]' Decode a JSON array containing instances of my Data Class people_json = '[{\"name\": \"lidatong\"}]' Person . schema () . loads ( people_json , many = True ) # [Person(name='lidatong')] Encode as part of a larger JSON object containing my Data Class (e.g. an HTTP request/response) import json response_dict = { 'response' : { 'person' : Person ( 'lidatong' ) . to_dict () } } response_json = json . dumps ( response_dict ) In this case, we do two steps. First, we encode the dataclass into a python dictionary rather than a JSON string, using .to_dict . Second, we leverage the built-in json.dumps to serialize our dataclass into a JSON string. Decode as part of a larger JSON object containing my Data Class (e.g. an HTTP response) import json response_dict = json . loads ( '{\"response\": {\"person\": {\"name\": \"lidatong\"}}}' ) person_dict = response_dict [ 'response' ] person = Person . from_dict ( person_dict ) In a similar vein to encoding above, we leverage the built-in json module. First, call json.loads to read the entire JSON object into a dictionary. We then access the key of the value containing the encoded dict of our Person that we want to decode ( response_dict['response'] ). Second, we load in the dictionary using Person.from_dict .","title":"Use my dataclass with JSON arrays or objects?"},{"location":"#encode-or-decode-into-python-listsdictionaries-rather-than-json","text":"This can be by calling .schema() and then using the corresponding encoder/decoder methods, ie. .load(...) / .dump(...) . Encode into a single Python dictionary person = Person ( 'lidatong' ) person . to_dict () # {'name': 'lidatong'} Encode into a list of Python dictionaries people = [ Person ( 'lidatong' )] Person . schema () . dump ( people , many = True ) # [{'name': 'lidatong'}] Decode a dictionary into a single dataclass instance person_dict = { 'name' : 'lidatong' } Person . from_dict ( person_dict ) # Person(name='lidatong') Decode a list of dictionaries into a list of dataclass instances people_dicts = [{ \"name\" : \"lidatong\" }] Person . schema () . load ( people_dicts , many = True ) # [Person(name='lidatong')]","title":"Encode or decode into Python lists/dictionaries rather than JSON?"},{"location":"#encode-or-decode-from-camelcase-or-kebab-case","text":"JSON letter case by convention is camelCase, in Python members are by convention snake_case. You can configure it to encode/decode from other casing schemes at both the class level and the field level. from dataclasses import dataclass , field from dataclasses_json import LetterCase , config , dataclass_json # changing casing at the class level @dataclass_json ( letter_case = LetterCase . CAMEL ) @dataclass class Person : given_name : str family_name : str Person ( 'Alice' , 'Liddell' ) . to_json () # '{\"givenName\": \"Alice\"}' Person . from_json ( '{\"givenName\": \"Alice\", \"familyName\": \"Liddell\"}' ) # Person('Alice', 'Liddell') # at the field level @dataclass_json @dataclass class Person : given_name : str = field ( metadata = config ( letter_case = LetterCase . CAMEL )) family_name : str Person ( 'Alice' , 'Liddell' ) . to_json () # '{\"givenName\": \"Alice\"}' # notice how the `family_name` field is still snake_case, because it wasn't configured above Person . from_json ( '{\"givenName\": \"Alice\", \"family_name\": \"Liddell\"}' ) # Person('Alice', 'Liddell') This library assumes your field follows the Python convention of snake_case naming. If your field is not snake_case to begin with and you attempt to parameterize LetterCase , the behavior of encoding/decoding is undefined (most likely it will result in subtle bugs).","title":"Encode or decode from camelCase (or kebab-case)?"},{"location":"#encode-or-decode-using-a-different-name","text":"from dataclasses import dataclass , field from dataclasses_json import config , dataclass_json @dataclass_json @dataclass class Person : given_name : str = field ( metadata = config ( field_name = \"overriddenGivenName\" )) Person ( given_name = \"Alice\" ) # Person('Alice') Person . from_json ( '{\"overriddenGivenName\": \"Alice\"}' ) # Person('Alice') Person ( 'Alice' ) . to_json () # {\"overriddenGivenName\": \"Alice\"}","title":"Encode or decode using a different name"},{"location":"#handle-missing-or-optional-field-values-when-decoding","text":"By default, any fields in your dataclass that use default or default_factory will have the values filled with the provided default, if the corresponding field is missing from the JSON you're decoding. Decode JSON with missing field @dataclass_json @dataclass class Student : id : int name : str = 'student' Student . from_json ( '{\"id\": 1}' ) # Student(id=1, name='student') Notice from_json filled the field name with the specified default 'student' when it was missing from the JSON. Sometimes you have fields that are typed as Optional , but you don't necessarily want to assign a default. In that case, you can use the infer_missing kwarg to make from_json infer the missing field value as None . Decode optional field without default @dataclass_json @dataclass class Tutor : id : int student : Optional [ Student ] = None Tutor . from_json ( '{\"id\": 1}' ) # Tutor(id=1, student=None) Personally I recommend you leverage dataclass defaults rather than using infer_missing , but if for some reason you need to decouple the behavior of JSON decoding from the field's default value, this will allow you to do so.","title":"Handle missing or optional field values when decoding?"},{"location":"#handle-unknown-extraneous-fields-in-json","text":"By default, it is up to the implementation what happens when a json_dataclass receives input parameters that are not defined. (the from_dict method ignores them, when loading using schema() a ValidationError is raised.) There are three ways to customize this behavior. Assume you want to instantiate a dataclass with the following dictionary: dump_dict = { \"endpoint\" : \"some_api_endpoint\" , \"data\" : { \"foo\" : 1 , \"bar\" : \"2\" }, \"undefined_field_name\" : [ 1 , 2 , 3 ]} You can enforce to always raise an error by setting the undefined keyword to Undefined.RAISE ( 'RAISE' as a case-insensitive string works as well). Of course it works normally if you don't pass any undefined parameters. from dataclasses_json import Undefined @dataclass_json ( undefined = Undefined . RAISE ) @dataclass () class ExactAPIDump : endpoint : str data : Dict [ str , Any ] dump = ExactAPIDump . from_dict ( dump_dict ) # raises UndefinedParameterError You can simply ignore any undefined parameters by setting the undefined keyword to Undefined.EXCLUDE ( 'EXCLUDE' as a case-insensitive string works as well). Note that you will not be able to retrieve them using to_dict : from dataclasses_json import Undefined @dataclass_json ( undefined = Undefined . EXCLUDE ) @dataclass () class DontCareAPIDump : endpoint : str data : Dict [ str , Any ] dump = DontCareAPIDump . from_dict ( dump_dict ) # DontCareAPIDump(endpoint='some_api_endpoint', data={'foo': 1, 'bar': '2'}) dump . to_dict () # {\"endpoint\": \"some_api_endpoint\", \"data\": {\"foo\": 1, \"bar\": \"2\"}} You can save them in a catch-all field and do whatever needs to be done later. Simply set the undefined keyword to Undefined.INCLUDE ( 'INCLUDE' as a case-insensitive string works as well) and define a field of type CatchAll where all unknown values will end up. This simply represents a dictionary that can hold anything. If there are no undefined parameters, this will be an empty dictionary. from dataclasses_json import Undefined , CatchAll @dataclass_json ( undefined = Undefined . INCLUDE ) @dataclass () class UnknownAPIDump : endpoint : str data : Dict [ str , Any ] unknown_things : CatchAll dump = UnknownAPIDump . from_dict ( dump_dict ) # UnknownAPIDump(endpoint='some_api_endpoint', data={'foo': 1, 'bar': '2'}, unknown_things={'undefined_field_name': [1, 2, 3]}) dump . to_dict () # {'endpoint': 'some_api_endpoint', 'data': {'foo': 1, 'bar': '2'}, 'undefined_field_name': [1, 2, 3]} Notes: - When using Undefined.INCLUDE , an UndefinedParameterError will be raised if you don't specify exactly one field of type CatchAll . - Note that LetterCase does not affect values written into the CatchAll field, they will be as they are given. - When specifying a default (or a default factory) for the the CatchAll -field, e.g. unknown_things: CatchAll = None , the default value will be used instead of an empty dict if there are no undefined parameters. - Calling init with non-keyword arguments resolves the arguments to the defined fields and writes everything else into the catch-all field. All 3 options work as well using schema().loads and schema().dumps , as long as you don't overwrite it by specifying schema(unknown=<a marshmallow value>) . marshmallow uses the same 3 keywords 'include', 'exclude', 'raise' . All 3 operations work as well using __init__ , e.g. UnknownAPIDump(**dump_dict) will not raise a TypeError , but write all unknown values to the field tagged as CatchAll . Classes tagged with EXCLUDE will also simply ignore unknown parameters. Note that classes tagged as RAISE still raise a TypeError , and not a UndefinedParameterError if supplied with unknown keywords.","title":"Handle unknown / extraneous fields in JSON?"},{"location":"#override-the-default-encode-decode-marshmallow-field-of-a-specific-field","text":"See Overriding","title":"Override the default encode / decode / marshmallow field of a specific field?"},{"location":"#handle-recursive-dataclasses","text":"Object hierarchies where fields are of the type that they are declared within require a small type hinting trick to declare the forward reference. from typing import Optional from dataclasses import dataclass from dataclasses_json import dataclass_json @dataclass_json @dataclass class Tree (): value : str left : Optional [ 'Tree' ] right : Optional [ 'Tree' ] Avoid using from __future__ import annotations as it will cause problems with the way dataclasses_json accesses the type annotations.","title":"Handle recursive dataclasses?"},{"location":"#marshmallow-interop","text":"Using the dataclass_json decorator or mixing in DataClassJsonMixin will provide you with an additional method .schema() . .schema() generates a schema exactly equivalent to manually creating a marshmallow schema for your dataclass. You can reference the marshmallow API docs to learn other ways you can use the schema returned by .schema() . You can pass in the exact same arguments to .schema() that you would when constructing a PersonSchema instance, e.g. .schema(many=True) , and they will get passed through to the marshmallow schema. from dataclasses import dataclass from dataclasses_json import dataclass_json @dataclass_json @dataclass class Person : name : str # You don't need to do this - it's generated for you by `.schema()`! from marshmallow import Schema , fields class PersonSchema ( Schema ): name = fields . Str () Briefly, on what's going on under the hood in the above examples: calling .schema() will have this library generate a marshmallow schema for you. It also fills in the corresponding object hook, so that marshmallow will create an instance of your Data Class on load (e.g. Person.schema().load returns a Person ) rather than a dict , which it does by default in marshmallow. Performance note .schema() is not cached (it generates the schema on every call), so if you have a nested Data Class you may want to save the result to a variable to avoid re-generation of the schema on every usage. person_schema = Person . schema () person_schema . dump ( people , many = True ) # later in the code... person_schema . dump ( person )","title":"Marshmallow interop"},{"location":"#overriding-extending","text":"","title":"Overriding / Extending"},{"location":"#overriding","text":"For example, you might want to encode/decode datetime objects using ISO format rather than the default timestamp . from dataclasses import dataclass , field from dataclasses_json import dataclass_json , config from datetime import datetime from marshmallow import fields @dataclass_json @dataclass class DataClassWithIsoDatetime : created_at : datetime = field ( metadata = config ( encoder = datetime . isoformat , decoder = datetime . fromisoformat , mm_field = fields . DateTime ( format = 'iso' ) ) )","title":"Overriding"},{"location":"#extending","text":"Similarly, you might want to extend dataclasses_json to encode date objects. from dataclasses import dataclass , field from dataclasses_json import dataclass_json , config from datetime import date from marshmallow import fields @dataclass_json @dataclass class DataClassWithIsoDatetime : created_at : date = field ( metadata = config ( encoder = date . isoformat , decoder = date . fromisoformat , mm_field = fields . DateTime ( format = 'iso' ) )) As you can see, you can override or extend the default codecs by providing a \"hook\" via a callable: - encoder : a callable, which will be invoked to convert the field value when encoding to JSON - decoder : a callable, which will be invoked to convert the JSON value when decoding from JSON - mm_field : a marshmallow field, which will affect the behavior of any operations involving .schema() Note that these hooks will be invoked regardless if you're using .to_json / dump / dumps and .from_json / load / loads . So apply overrides / extensions judiciously, making sure to carefully consider whether the interaction of the encode/decode/mm_field is consistent with what you expect!","title":"Extending"},{"location":"#what-if-i-have-other-dataclass-field-extensions-that-rely-on-metadata","text":"All the dataclasses_json.config does is return a mapping, namespaced under the key 'dataclasses_json' . Say there's another module, other_dataclass_package that uses metadata. Here's how you solve your problem: metadata = { 'other_dataclass_package' : 'some metadata...' } # pre-existing metadata for another dataclass package dataclass_json_config = config ( encoder = datetime . isoformat , decoder = datetime . fromisoformat , mm_field = fields . DateTime ( format = 'iso' ) ) metadata . update ( dataclass_json_config ) @dataclass_json @dataclass class DataClassWithIsoDatetime : created_at : datetime = field ( metadata = metadata ) You can also manually specify the dataclass_json configuration mapping. @dataclass_json @dataclass class DataClassWithIsoDatetime : created_at : date = field ( metadata = { 'dataclasses_json' : { 'encoder' : date . isoformat , 'decoder' : date . fromisoformat , 'mm_field' : fields . DateTime ( format = 'iso' ) }} )","title":"What if I have other dataclass field extensions that rely on metadata"},{"location":"#a-larger-example","text":"from dataclasses import dataclass from dataclasses_json import dataclass_json from typing import List @dataclass_json @dataclass ( frozen = True ) class Minion : name : str @dataclass_json @dataclass ( frozen = True ) class Boss : minions : List [ Minion ] boss = Boss ([ Minion ( 'evil minion' ), Minion ( 'very evil minion' )]) boss_json = \"\"\" { \"minions\": [ { \"name\": \"evil minion\" }, { \"name\": \"very evil minion\" } ] } \"\"\" . strip () assert boss . to_json ( indent = 4 ) == boss_json assert Boss . from_json ( boss_json ) == boss","title":"A larger example"},{"location":"#performance","text":"Take a look at this issue","title":"Performance"},{"location":"#versioning","text":"Note this library is still pre-1.0.0 (SEMVER). The current convention is: - PATCH version upgrades for bug fixes and minor feature additions. - MINOR version upgrades for big API features and breaking changes. Once this library is 1.0.0, it will follow standard SEMVER conventions.","title":"Versioning"},{"location":"#roadmap","text":"Currently the focus is on investigating and fixing bugs in this library, working on performance, and finishing this issue . That said, if you think there's a feature missing / something new needed in the library, please see the contributing section below.","title":"Roadmap"},{"location":"#contributing","text":"First of all, thank you for being interested in contributing to this library. I really appreciate you taking the time to work on this project. If you're just interested in getting into the code, a good place to start are issues tagged as bugs. If introducing a new feature, especially one that modifies the public API, consider submitting an issue for discussion before a PR. Please also take a look at existing issues / PRs to see what you're proposing has already been covered before / exists. I like to follow the commit conventions documented here","title":"Contributing"},{"location":"reference/dataclasses_json/","text":"Module dataclasses_json View Source # flake8: noqa from dataclasses_json.api import ( DataClassJsonMixin , dataclass_json ) from dataclasses_json.cfg import ( config , global_config , Exclude , LetterCase ) from dataclasses_json.undefined import CatchAll , Undefined __all__ = [ 'DataClassJsonMixin' , 'LetterCase' , 'dataclass_json' , 'config' , 'global_config' , 'Exclude' , 'CatchAll' , 'Undefined' ] Sub-modules dataclasses_json.api dataclasses_json.cfg dataclasses_json.core dataclasses_json.mm dataclasses_json.stringcase dataclasses_json.undefined dataclasses_json.utils Variables CatchAll global_config Functions config def config ( metadata : dict = None , * , encoder : Callable = None , decoder : Callable = None , mm_field : marshmallow . fields . Field = None , letter_case : Union [ Callable [[ str ], str ], dataclasses_json . cfg . LetterCase , NoneType ] = None , undefined : Union [ str , dataclasses_json . undefined . Undefined , NoneType ] = None , field_name : str = None , exclude : Union [ Callable [[ str , ~ T ], bool ], dataclasses_json . cfg . Exclude , NoneType ] = None ) -> Dict [ str , dict ] View Source def config ( metadata : dict = None , * , # TODO : these can be typed more precisely # Specifically , a Callable [ A, B ] , where ` B ` is bound as a JSON type encoder : Callable = None , decoder : Callable = None , mm_field : MarshmallowField = None , letter_case : Union [ Callable[[str ] , str ] , LetterCase , None ] = None , undefined : Optional [ Union[str, Undefined ] ] = None , field_name : str = None , exclude : Union [ Callable[[str, T ] , bool ] , Exclude , None ] = None , ) -> Dict [ str, dict ] : if metadata is None : metadata = {} lib_metadata = metadata . setdefault ( 'dataclasses_json' , {} ) if encoder is not None : lib_metadata [ 'encoder' ] = encoder if decoder is not None : lib_metadata [ 'decoder' ] = decoder if mm_field is not None : lib_metadata [ 'mm_field' ] = mm_field if field_name is not None : if letter_case is not None : @functools . wraps ( letter_case ) # type : ignore def override ( _ , _letter_case = letter_case , _field_name = field_name ) : return _letter_case ( _field_name ) else : def override ( _ , _field_name = field_name ) : # type : ignore return _field_name letter_case = override if letter_case is not None : lib_metadata [ 'letter_case' ] = letter_case if undefined is not None : # Get the corresponding action for undefined parameters if isinstance ( undefined , str ) : if not hasattr ( Undefined , undefined . upper ()) : valid_actions = list ( action . name for action in Undefined ) raise UndefinedParameterError ( f \"Invalid undefined parameter action, \" f \"must be one of {valid_actions}\" ) undefined = Undefined [ undefined.upper() ] lib_metadata [ 'undefined' ] = undefined if exclude is not None : lib_metadata [ 'exclude' ] = exclude return metadata dataclass_json def dataclass_json ( _cls = None , * , letter_case = None , undefined : Union [ str , dataclasses_json . undefined . Undefined , NoneType ] = None ) Based on the code in the dataclasses module to handle optional-parens decorators. See example below: @dataclass_json @dataclass_json(letter_case=LetterCase.CAMEL) class Example: ... View Source def dataclass_json ( _cls = None , * , letter_case = None , undefined : Optional [ Union [ str , Undefined ]] = None ): \"\"\" Based on the code in the `dataclasses` module to handle optional-parens decorators. See example below: @dataclass_json @dataclass_json(letter_case=LetterCase.CAMEL) class Example: ... \"\"\" def wrap ( cls ): return _process_class ( cls , letter_case , undefined ) if _cls is None : return wrap return wrap ( _cls ) Classes DataClassJsonMixin class DataClassJsonMixin ( / , * args , ** kwargs ) DataClassJsonMixin is an ABC that functions as a Mixin. As with other ABCs, it should not be instantiated directly. View Source class DataClassJsonMixin ( abc . ABC ) : \"\"\" DataClassJsonMixin is an ABC that functions as a Mixin. As with other ABCs, it should not be instantiated directly. \"\"\" dataclass_json_config = None def to_json ( self , * , skipkeys : bool = False , ensure_ascii : bool = True , check_circular : bool = True , allow_nan : bool = True , indent : Optional [ Union[int, str ] ] = None , separators : Tuple [ str, str ] = None , default : Callable = None , sort_keys : bool = False , ** kw ) -> str : return json . dumps ( self . to_dict ( encode_json = False ), cls = _ExtendedEncoder , skipkeys = skipkeys , ensure_ascii = ensure_ascii , check_circular = check_circular , allow_nan = allow_nan , indent = indent , separators = separators , default = default , sort_keys = sort_keys , ** kw ) @classmethod def from_json ( cls : Type [ A ] , s : JsonData , * , parse_float = None , parse_int = None , parse_constant = None , infer_missing = False , ** kw ) -> A : kvs = json . loads ( s , parse_float = parse_float , parse_int = parse_int , parse_constant = parse_constant , ** kw ) return cls . from_dict ( kvs , infer_missing = infer_missing ) @classmethod def from_dict ( cls : Type [ A ] , kvs : Json , * , infer_missing = False ) -> A : return _decode_dataclass ( cls , kvs , infer_missing ) def to_dict ( self , encode_json = False ) -> Dict [ str, Json ] : return _asdict ( self , encode_json = encode_json ) @classmethod def schema ( cls : Type [ A ] , * , infer_missing : bool = False , only = None , exclude = (), many : bool = False , context = None , load_only = (), dump_only = (), partial : bool = False , unknown = None ) -> SchemaType : Schema = build_schema ( cls , DataClassJsonMixin , infer_missing , partial ) if unknown is None : undefined_parameter_action = _undefined_parameter_action_safe ( cls ) if undefined_parameter_action is not None : # We can just make use of the same - named mm keywords unknown = undefined_parameter_action . name . lower () return Schema ( only = only , exclude = exclude , many = many , context = context , load_only = load_only , dump_only = dump_only , partial = partial , unknown = unknown ) Ancestors (in MRO) abc.ABC Class variables dataclass_json_config Static methods from_dict def from_dict ( kvs : Union [ dict , list , str , int , float , bool , NoneType ], * , infer_missing = False ) -> ~ A View Source @classmethod def from_dict ( cls : Type [ A ] , kvs : Json , * , infer_missing = False ) -> A : return _decode_dataclass ( cls , kvs , infer_missing ) from_json def from_json ( s : Union [ str , bytes , bytearray ], * , parse_float = None , parse_int = None , parse_constant = None , infer_missing = False , ** kw ) -> ~ A View Source @classmethod def from_json ( cls : Type [ A ] , s : JsonData , * , parse_float = None , parse_int = None , parse_constant = None , infer_missing = False , ** kw ) -> A : kvs = json . loads ( s , parse_float = parse_float , parse_int = parse_int , parse_constant = parse_constant , ** kw ) return cls . from_dict ( kvs , infer_missing = infer_missing ) schema def schema ( * , infer_missing : bool = False , only = None , exclude = (), many : bool = False , context = None , load_only = (), dump_only = (), partial : bool = False , unknown = None ) -> dataclasses_json . mm . SchemaF [ ~ A ] View Source @classmethod def schema ( cls : Type [ A ] , * , infer_missing : bool = False , only = None , exclude = (), many : bool = False , context = None , load_only = (), dump_only = (), partial : bool = False , unknown = None ) -> SchemaType : Schema = build_schema ( cls , DataClassJsonMixin , infer_missing , partial ) if unknown is None : undefined_parameter_action = _undefined_parameter_action_safe ( cls ) if undefined_parameter_action is not None : # We can just make use of the same - named mm keywords unknown = undefined_parameter_action . name . lower () return Schema ( only = only , exclude = exclude , many = many , context = context , load_only = load_only , dump_only = dump_only , partial = partial , unknown = unknown ) Methods to_dict def to_dict ( self , encode_json = False ) -> Dict [ str , Union [ dict , list , str , int , float , bool , NoneType ]] View Source def to_dict ( self , encode_json = False ) -> Dict [ str , Json ]: return _asdict ( self , encode_json = encode_json ) to_json def to_json ( self , * , skipkeys : bool = False , ensure_ascii : bool = True , check_circular : bool = True , allow_nan : bool = True , indent : Union [ int , str , NoneType ] = None , separators : Tuple [ str , str ] = None , default : Callable = None , sort_keys : bool = False , ** kw ) -> str View Source def to_json ( self , * , skipkeys : bool = False , ensure_ascii : bool = True , check_circular : bool = True , allow_nan : bool = True , indent : Optional [ Union [ int , str ]] = None , separators : Tuple [ str , str ] = None , default : Callable = None , sort_keys : bool = False , ** kw ) -> str : return json . dumps ( self . to_dict ( encode_json = False ), cls = _ExtendedEncoder , skipkeys = skipkeys , ensure_ascii = ensure_ascii , check_circular = check_circular , allow_nan = allow_nan , indent = indent , separators = separators , default = default , sort_keys = sort_keys , ** kw ) Exclude class Exclude ( / , * args , ** kwargs ) Pre-defined constants for exclusion. By default, fields are configured to be included. View Source class Exclude : \"\"\" Pre-defined constants for exclusion. By default, fields are configured to be included. \"\"\" ALWAYS : Callable [ [T ] , bool ] = lambda _ : True NEVER : Callable [ [T ] , bool ] = lambda _ : False Methods ALWAYS def ALWAYS ( _ ) View Source ALWAYS : Callable [ [T ] , bool ] = lambda _ : True NEVER def NEVER ( _ ) View Source NEVER : Callable [ [T ] , bool ] = lambda _ : False LetterCase class LetterCase ( / , * args , ** kwargs ) An enumeration. View Source class LetterCase ( Enum ): CAMEL = camelcase KEBAB = spinalcase SNAKE = snakecase PASCAL = pascalcase Ancestors (in MRO) enum.Enum Class variables CAMEL KEBAB PASCAL SNAKE name value Undefined class Undefined ( / , * args , ** kwargs ) Choose the behavior what happens when an undefined parameter is encountered during class initialization. View Source class Undefined ( Enum ): \"\"\" Choose the behavior what happens when an undefined parameter is encountered during class initialization. \"\"\" INCLUDE = _CatchAllUndefinedParameters RAISE = _RaiseUndefinedParameters EXCLUDE = _IgnoreUndefinedParameters Ancestors (in MRO) enum.Enum Class variables EXCLUDE INCLUDE RAISE name value","title":"Index"},{"location":"reference/dataclasses_json/#module-dataclasses_json","text":"View Source # flake8: noqa from dataclasses_json.api import ( DataClassJsonMixin , dataclass_json ) from dataclasses_json.cfg import ( config , global_config , Exclude , LetterCase ) from dataclasses_json.undefined import CatchAll , Undefined __all__ = [ 'DataClassJsonMixin' , 'LetterCase' , 'dataclass_json' , 'config' , 'global_config' , 'Exclude' , 'CatchAll' , 'Undefined' ]","title":"Module dataclasses_json"},{"location":"reference/dataclasses_json/#sub-modules","text":"dataclasses_json.api dataclasses_json.cfg dataclasses_json.core dataclasses_json.mm dataclasses_json.stringcase dataclasses_json.undefined dataclasses_json.utils","title":"Sub-modules"},{"location":"reference/dataclasses_json/#variables","text":"CatchAll global_config","title":"Variables"},{"location":"reference/dataclasses_json/#functions","text":"","title":"Functions"},{"location":"reference/dataclasses_json/#config","text":"def config ( metadata : dict = None , * , encoder : Callable = None , decoder : Callable = None , mm_field : marshmallow . fields . Field = None , letter_case : Union [ Callable [[ str ], str ], dataclasses_json . cfg . LetterCase , NoneType ] = None , undefined : Union [ str , dataclasses_json . undefined . Undefined , NoneType ] = None , field_name : str = None , exclude : Union [ Callable [[ str , ~ T ], bool ], dataclasses_json . cfg . Exclude , NoneType ] = None ) -> Dict [ str , dict ] View Source def config ( metadata : dict = None , * , # TODO : these can be typed more precisely # Specifically , a Callable [ A, B ] , where ` B ` is bound as a JSON type encoder : Callable = None , decoder : Callable = None , mm_field : MarshmallowField = None , letter_case : Union [ Callable[[str ] , str ] , LetterCase , None ] = None , undefined : Optional [ Union[str, Undefined ] ] = None , field_name : str = None , exclude : Union [ Callable[[str, T ] , bool ] , Exclude , None ] = None , ) -> Dict [ str, dict ] : if metadata is None : metadata = {} lib_metadata = metadata . setdefault ( 'dataclasses_json' , {} ) if encoder is not None : lib_metadata [ 'encoder' ] = encoder if decoder is not None : lib_metadata [ 'decoder' ] = decoder if mm_field is not None : lib_metadata [ 'mm_field' ] = mm_field if field_name is not None : if letter_case is not None : @functools . wraps ( letter_case ) # type : ignore def override ( _ , _letter_case = letter_case , _field_name = field_name ) : return _letter_case ( _field_name ) else : def override ( _ , _field_name = field_name ) : # type : ignore return _field_name letter_case = override if letter_case is not None : lib_metadata [ 'letter_case' ] = letter_case if undefined is not None : # Get the corresponding action for undefined parameters if isinstance ( undefined , str ) : if not hasattr ( Undefined , undefined . upper ()) : valid_actions = list ( action . name for action in Undefined ) raise UndefinedParameterError ( f \"Invalid undefined parameter action, \" f \"must be one of {valid_actions}\" ) undefined = Undefined [ undefined.upper() ] lib_metadata [ 'undefined' ] = undefined if exclude is not None : lib_metadata [ 'exclude' ] = exclude return metadata","title":"config"},{"location":"reference/dataclasses_json/#dataclass_json","text":"def dataclass_json ( _cls = None , * , letter_case = None , undefined : Union [ str , dataclasses_json . undefined . Undefined , NoneType ] = None ) Based on the code in the dataclasses module to handle optional-parens decorators. See example below: @dataclass_json @dataclass_json(letter_case=LetterCase.CAMEL) class Example: ... View Source def dataclass_json ( _cls = None , * , letter_case = None , undefined : Optional [ Union [ str , Undefined ]] = None ): \"\"\" Based on the code in the `dataclasses` module to handle optional-parens decorators. See example below: @dataclass_json @dataclass_json(letter_case=LetterCase.CAMEL) class Example: ... \"\"\" def wrap ( cls ): return _process_class ( cls , letter_case , undefined ) if _cls is None : return wrap return wrap ( _cls )","title":"dataclass_json"},{"location":"reference/dataclasses_json/#classes","text":"","title":"Classes"},{"location":"reference/dataclasses_json/#dataclassjsonmixin","text":"class DataClassJsonMixin ( / , * args , ** kwargs ) DataClassJsonMixin is an ABC that functions as a Mixin. As with other ABCs, it should not be instantiated directly. View Source class DataClassJsonMixin ( abc . ABC ) : \"\"\" DataClassJsonMixin is an ABC that functions as a Mixin. As with other ABCs, it should not be instantiated directly. \"\"\" dataclass_json_config = None def to_json ( self , * , skipkeys : bool = False , ensure_ascii : bool = True , check_circular : bool = True , allow_nan : bool = True , indent : Optional [ Union[int, str ] ] = None , separators : Tuple [ str, str ] = None , default : Callable = None , sort_keys : bool = False , ** kw ) -> str : return json . dumps ( self . to_dict ( encode_json = False ), cls = _ExtendedEncoder , skipkeys = skipkeys , ensure_ascii = ensure_ascii , check_circular = check_circular , allow_nan = allow_nan , indent = indent , separators = separators , default = default , sort_keys = sort_keys , ** kw ) @classmethod def from_json ( cls : Type [ A ] , s : JsonData , * , parse_float = None , parse_int = None , parse_constant = None , infer_missing = False , ** kw ) -> A : kvs = json . loads ( s , parse_float = parse_float , parse_int = parse_int , parse_constant = parse_constant , ** kw ) return cls . from_dict ( kvs , infer_missing = infer_missing ) @classmethod def from_dict ( cls : Type [ A ] , kvs : Json , * , infer_missing = False ) -> A : return _decode_dataclass ( cls , kvs , infer_missing ) def to_dict ( self , encode_json = False ) -> Dict [ str, Json ] : return _asdict ( self , encode_json = encode_json ) @classmethod def schema ( cls : Type [ A ] , * , infer_missing : bool = False , only = None , exclude = (), many : bool = False , context = None , load_only = (), dump_only = (), partial : bool = False , unknown = None ) -> SchemaType : Schema = build_schema ( cls , DataClassJsonMixin , infer_missing , partial ) if unknown is None : undefined_parameter_action = _undefined_parameter_action_safe ( cls ) if undefined_parameter_action is not None : # We can just make use of the same - named mm keywords unknown = undefined_parameter_action . name . lower () return Schema ( only = only , exclude = exclude , many = many , context = context , load_only = load_only , dump_only = dump_only , partial = partial , unknown = unknown )","title":"DataClassJsonMixin"},{"location":"reference/dataclasses_json/#ancestors-in-mro","text":"abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/dataclasses_json/#class-variables","text":"dataclass_json_config","title":"Class variables"},{"location":"reference/dataclasses_json/#static-methods","text":"","title":"Static methods"},{"location":"reference/dataclasses_json/#from_dict","text":"def from_dict ( kvs : Union [ dict , list , str , int , float , bool , NoneType ], * , infer_missing = False ) -> ~ A View Source @classmethod def from_dict ( cls : Type [ A ] , kvs : Json , * , infer_missing = False ) -> A : return _decode_dataclass ( cls , kvs , infer_missing )","title":"from_dict"},{"location":"reference/dataclasses_json/#from_json","text":"def from_json ( s : Union [ str , bytes , bytearray ], * , parse_float = None , parse_int = None , parse_constant = None , infer_missing = False , ** kw ) -> ~ A View Source @classmethod def from_json ( cls : Type [ A ] , s : JsonData , * , parse_float = None , parse_int = None , parse_constant = None , infer_missing = False , ** kw ) -> A : kvs = json . loads ( s , parse_float = parse_float , parse_int = parse_int , parse_constant = parse_constant , ** kw ) return cls . from_dict ( kvs , infer_missing = infer_missing )","title":"from_json"},{"location":"reference/dataclasses_json/#schema","text":"def schema ( * , infer_missing : bool = False , only = None , exclude = (), many : bool = False , context = None , load_only = (), dump_only = (), partial : bool = False , unknown = None ) -> dataclasses_json . mm . SchemaF [ ~ A ] View Source @classmethod def schema ( cls : Type [ A ] , * , infer_missing : bool = False , only = None , exclude = (), many : bool = False , context = None , load_only = (), dump_only = (), partial : bool = False , unknown = None ) -> SchemaType : Schema = build_schema ( cls , DataClassJsonMixin , infer_missing , partial ) if unknown is None : undefined_parameter_action = _undefined_parameter_action_safe ( cls ) if undefined_parameter_action is not None : # We can just make use of the same - named mm keywords unknown = undefined_parameter_action . name . lower () return Schema ( only = only , exclude = exclude , many = many , context = context , load_only = load_only , dump_only = dump_only , partial = partial , unknown = unknown )","title":"schema"},{"location":"reference/dataclasses_json/#methods","text":"","title":"Methods"},{"location":"reference/dataclasses_json/#to_dict","text":"def to_dict ( self , encode_json = False ) -> Dict [ str , Union [ dict , list , str , int , float , bool , NoneType ]] View Source def to_dict ( self , encode_json = False ) -> Dict [ str , Json ]: return _asdict ( self , encode_json = encode_json )","title":"to_dict"},{"location":"reference/dataclasses_json/#to_json","text":"def to_json ( self , * , skipkeys : bool = False , ensure_ascii : bool = True , check_circular : bool = True , allow_nan : bool = True , indent : Union [ int , str , NoneType ] = None , separators : Tuple [ str , str ] = None , default : Callable = None , sort_keys : bool = False , ** kw ) -> str View Source def to_json ( self , * , skipkeys : bool = False , ensure_ascii : bool = True , check_circular : bool = True , allow_nan : bool = True , indent : Optional [ Union [ int , str ]] = None , separators : Tuple [ str , str ] = None , default : Callable = None , sort_keys : bool = False , ** kw ) -> str : return json . dumps ( self . to_dict ( encode_json = False ), cls = _ExtendedEncoder , skipkeys = skipkeys , ensure_ascii = ensure_ascii , check_circular = check_circular , allow_nan = allow_nan , indent = indent , separators = separators , default = default , sort_keys = sort_keys , ** kw )","title":"to_json"},{"location":"reference/dataclasses_json/#exclude","text":"class Exclude ( / , * args , ** kwargs ) Pre-defined constants for exclusion. By default, fields are configured to be included. View Source class Exclude : \"\"\" Pre-defined constants for exclusion. By default, fields are configured to be included. \"\"\" ALWAYS : Callable [ [T ] , bool ] = lambda _ : True NEVER : Callable [ [T ] , bool ] = lambda _ : False","title":"Exclude"},{"location":"reference/dataclasses_json/#methods_1","text":"","title":"Methods"},{"location":"reference/dataclasses_json/#always","text":"def ALWAYS ( _ ) View Source ALWAYS : Callable [ [T ] , bool ] = lambda _ : True","title":"ALWAYS"},{"location":"reference/dataclasses_json/#never","text":"def NEVER ( _ ) View Source NEVER : Callable [ [T ] , bool ] = lambda _ : False","title":"NEVER"},{"location":"reference/dataclasses_json/#lettercase","text":"class LetterCase ( / , * args , ** kwargs ) An enumeration. View Source class LetterCase ( Enum ): CAMEL = camelcase KEBAB = spinalcase SNAKE = snakecase PASCAL = pascalcase","title":"LetterCase"},{"location":"reference/dataclasses_json/#ancestors-in-mro_1","text":"enum.Enum","title":"Ancestors (in MRO)"},{"location":"reference/dataclasses_json/#class-variables_1","text":"CAMEL KEBAB PASCAL SNAKE name value","title":"Class variables"},{"location":"reference/dataclasses_json/#undefined","text":"class Undefined ( / , * args , ** kwargs ) Choose the behavior what happens when an undefined parameter is encountered during class initialization. View Source class Undefined ( Enum ): \"\"\" Choose the behavior what happens when an undefined parameter is encountered during class initialization. \"\"\" INCLUDE = _CatchAllUndefinedParameters RAISE = _RaiseUndefinedParameters EXCLUDE = _IgnoreUndefinedParameters","title":"Undefined"},{"location":"reference/dataclasses_json/#ancestors-in-mro_2","text":"enum.Enum","title":"Ancestors (in MRO)"},{"location":"reference/dataclasses_json/#class-variables_2","text":"EXCLUDE INCLUDE RAISE name value","title":"Class variables"},{"location":"reference/dataclasses_json/api/","text":"Module dataclasses_json.api View Source import abc import json from typing import ( Any , Callable , Dict , List , Optional , Tuple , Type , TypeVar , Union ) from dataclasses_json.cfg import config , LetterCase # noqa: F401 from dataclasses_json.core import ( Json , _ExtendedEncoder , _asdict , _decode_dataclass ) from dataclasses_json.mm import ( JsonData , SchemaType , build_schema ) from dataclasses_json.undefined import Undefined from dataclasses_json.utils import ( _handle_undefined_parameters_safe , _undefined_parameter_action_safe ) A = TypeVar ( 'A' , bound = \"DataClassJsonMixin\" ) B = TypeVar ( 'B' ) C = TypeVar ( 'C' ) Fields = List [ Tuple [ str , Any ]] class DataClassJsonMixin ( abc . ABC ): \"\"\" DataClassJsonMixin is an ABC that functions as a Mixin. As with other ABCs, it should not be instantiated directly. \"\"\" dataclass_json_config = None def to_json ( self , * , skipkeys : bool = False , ensure_ascii : bool = True , check_circular : bool = True , allow_nan : bool = True , indent : Optional [ Union [ int , str ]] = None , separators : Tuple [ str , str ] = None , default : Callable = None , sort_keys : bool = False , ** kw ) -> str : return json . dumps ( self . to_dict ( encode_json = False ), cls = _ExtendedEncoder , skipkeys = skipkeys , ensure_ascii = ensure_ascii , check_circular = check_circular , allow_nan = allow_nan , indent = indent , separators = separators , default = default , sort_keys = sort_keys , ** kw ) @classmethod def from_json ( cls : Type [ A ], s : JsonData , * , parse_float = None , parse_int = None , parse_constant = None , infer_missing = False , ** kw ) -> A : kvs = json . loads ( s , parse_float = parse_float , parse_int = parse_int , parse_constant = parse_constant , ** kw ) return cls . from_dict ( kvs , infer_missing = infer_missing ) @classmethod def from_dict ( cls : Type [ A ], kvs : Json , * , infer_missing = False ) -> A : return _decode_dataclass ( cls , kvs , infer_missing ) def to_dict ( self , encode_json = False ) -> Dict [ str , Json ]: return _asdict ( self , encode_json = encode_json ) @classmethod def schema ( cls : Type [ A ], * , infer_missing : bool = False , only = None , exclude = (), many : bool = False , context = None , load_only = (), dump_only = (), partial : bool = False , unknown = None ) -> SchemaType : Schema = build_schema ( cls , DataClassJsonMixin , infer_missing , partial ) if unknown is None : undefined_parameter_action = _undefined_parameter_action_safe ( cls ) if undefined_parameter_action is not None : # We can just make use of the same-named mm keywords unknown = undefined_parameter_action . name . lower () return Schema ( only = only , exclude = exclude , many = many , context = context , load_only = load_only , dump_only = dump_only , partial = partial , unknown = unknown ) def dataclass_json ( _cls = None , * , letter_case = None , undefined : Optional [ Union [ str , Undefined ]] = None ): \"\"\" Based on the code in the `dataclasses` module to handle optional-parens decorators. See example below: @dataclass_json @dataclass_json(letter_case=LetterCase.CAMEL) class Example: ... \"\"\" def wrap ( cls ): return _process_class ( cls , letter_case , undefined ) if _cls is None : return wrap return wrap ( _cls ) def _process_class ( cls , letter_case , undefined ): if letter_case is not None or undefined is not None : cls . dataclass_json_config = config ( letter_case = letter_case , undefined = undefined )[ 'dataclasses_json' ] cls . to_json = DataClassJsonMixin . to_json # unwrap and rewrap classmethod to tag it to cls rather than the literal # DataClassJsonMixin ABC cls . from_json = classmethod ( DataClassJsonMixin . from_json . __func__ ) cls . to_dict = DataClassJsonMixin . to_dict cls . from_dict = classmethod ( DataClassJsonMixin . from_dict . __func__ ) cls . schema = classmethod ( DataClassJsonMixin . schema . __func__ ) cls . __init__ = _handle_undefined_parameters_safe ( cls , kvs = (), usage = \"init\" ) # register cls as a virtual subclass of DataClassJsonMixin DataClassJsonMixin . register ( cls ) return cls Variables A B C Fields Functions dataclass_json def dataclass_json ( _cls = None , * , letter_case = None , undefined : Union [ str , dataclasses_json . undefined . Undefined , NoneType ] = None ) Based on the code in the dataclasses module to handle optional-parens decorators. See example below: @dataclass_json @dataclass_json(letter_case=LetterCase.CAMEL) class Example: ... View Source def dataclass_json ( _cls = None , * , letter_case = None , undefined : Optional [ Union [ str , Undefined ]] = None ): \"\"\" Based on the code in the `dataclasses` module to handle optional-parens decorators. See example below: @dataclass_json @dataclass_json(letter_case=LetterCase.CAMEL) class Example: ... \"\"\" def wrap ( cls ): return _process_class ( cls , letter_case , undefined ) if _cls is None : return wrap return wrap ( _cls ) Classes DataClassJsonMixin class DataClassJsonMixin ( / , * args , ** kwargs ) DataClassJsonMixin is an ABC that functions as a Mixin. As with other ABCs, it should not be instantiated directly. View Source class DataClassJsonMixin ( abc . ABC ) : \"\"\" DataClassJsonMixin is an ABC that functions as a Mixin. As with other ABCs, it should not be instantiated directly. \"\"\" dataclass_json_config = None def to_json ( self , * , skipkeys : bool = False , ensure_ascii : bool = True , check_circular : bool = True , allow_nan : bool = True , indent : Optional [ Union[int, str ] ] = None , separators : Tuple [ str, str ] = None , default : Callable = None , sort_keys : bool = False , ** kw ) -> str : return json . dumps ( self . to_dict ( encode_json = False ), cls = _ExtendedEncoder , skipkeys = skipkeys , ensure_ascii = ensure_ascii , check_circular = check_circular , allow_nan = allow_nan , indent = indent , separators = separators , default = default , sort_keys = sort_keys , ** kw ) @classmethod def from_json ( cls : Type [ A ] , s : JsonData , * , parse_float = None , parse_int = None , parse_constant = None , infer_missing = False , ** kw ) -> A : kvs = json . loads ( s , parse_float = parse_float , parse_int = parse_int , parse_constant = parse_constant , ** kw ) return cls . from_dict ( kvs , infer_missing = infer_missing ) @classmethod def from_dict ( cls : Type [ A ] , kvs : Json , * , infer_missing = False ) -> A : return _decode_dataclass ( cls , kvs , infer_missing ) def to_dict ( self , encode_json = False ) -> Dict [ str, Json ] : return _asdict ( self , encode_json = encode_json ) @classmethod def schema ( cls : Type [ A ] , * , infer_missing : bool = False , only = None , exclude = (), many : bool = False , context = None , load_only = (), dump_only = (), partial : bool = False , unknown = None ) -> SchemaType : Schema = build_schema ( cls , DataClassJsonMixin , infer_missing , partial ) if unknown is None : undefined_parameter_action = _undefined_parameter_action_safe ( cls ) if undefined_parameter_action is not None : # We can just make use of the same - named mm keywords unknown = undefined_parameter_action . name . lower () return Schema ( only = only , exclude = exclude , many = many , context = context , load_only = load_only , dump_only = dump_only , partial = partial , unknown = unknown ) Ancestors (in MRO) abc.ABC Class variables dataclass_json_config Static methods from_dict def from_dict ( kvs : Union [ dict , list , str , int , float , bool , NoneType ], * , infer_missing = False ) -> ~ A View Source @classmethod def from_dict ( cls : Type [ A ] , kvs : Json , * , infer_missing = False ) -> A : return _decode_dataclass ( cls , kvs , infer_missing ) from_json def from_json ( s : Union [ str , bytes , bytearray ], * , parse_float = None , parse_int = None , parse_constant = None , infer_missing = False , ** kw ) -> ~ A View Source @classmethod def from_json ( cls : Type [ A ] , s : JsonData , * , parse_float = None , parse_int = None , parse_constant = None , infer_missing = False , ** kw ) -> A : kvs = json . loads ( s , parse_float = parse_float , parse_int = parse_int , parse_constant = parse_constant , ** kw ) return cls . from_dict ( kvs , infer_missing = infer_missing ) schema def schema ( * , infer_missing : bool = False , only = None , exclude = (), many : bool = False , context = None , load_only = (), dump_only = (), partial : bool = False , unknown = None ) -> dataclasses_json . mm . SchemaF [ ~ A ] View Source @classmethod def schema ( cls : Type [ A ] , * , infer_missing : bool = False , only = None , exclude = (), many : bool = False , context = None , load_only = (), dump_only = (), partial : bool = False , unknown = None ) -> SchemaType : Schema = build_schema ( cls , DataClassJsonMixin , infer_missing , partial ) if unknown is None : undefined_parameter_action = _undefined_parameter_action_safe ( cls ) if undefined_parameter_action is not None : # We can just make use of the same - named mm keywords unknown = undefined_parameter_action . name . lower () return Schema ( only = only , exclude = exclude , many = many , context = context , load_only = load_only , dump_only = dump_only , partial = partial , unknown = unknown ) Methods to_dict def to_dict ( self , encode_json = False ) -> Dict [ str , Union [ dict , list , str , int , float , bool , NoneType ]] View Source def to_dict ( self , encode_json = False ) -> Dict [ str , Json ]: return _asdict ( self , encode_json = encode_json ) to_json def to_json ( self , * , skipkeys : bool = False , ensure_ascii : bool = True , check_circular : bool = True , allow_nan : bool = True , indent : Union [ int , str , NoneType ] = None , separators : Tuple [ str , str ] = None , default : Callable = None , sort_keys : bool = False , ** kw ) -> str View Source def to_json ( self , * , skipkeys : bool = False , ensure_ascii : bool = True , check_circular : bool = True , allow_nan : bool = True , indent : Optional [ Union [ int , str ]] = None , separators : Tuple [ str , str ] = None , default : Callable = None , sort_keys : bool = False , ** kw ) -> str : return json . dumps ( self . to_dict ( encode_json = False ), cls = _ExtendedEncoder , skipkeys = skipkeys , ensure_ascii = ensure_ascii , check_circular = check_circular , allow_nan = allow_nan , indent = indent , separators = separators , default = default , sort_keys = sort_keys , ** kw )","title":"API"},{"location":"reference/dataclasses_json/api/#module-dataclasses_jsonapi","text":"View Source import abc import json from typing import ( Any , Callable , Dict , List , Optional , Tuple , Type , TypeVar , Union ) from dataclasses_json.cfg import config , LetterCase # noqa: F401 from dataclasses_json.core import ( Json , _ExtendedEncoder , _asdict , _decode_dataclass ) from dataclasses_json.mm import ( JsonData , SchemaType , build_schema ) from dataclasses_json.undefined import Undefined from dataclasses_json.utils import ( _handle_undefined_parameters_safe , _undefined_parameter_action_safe ) A = TypeVar ( 'A' , bound = \"DataClassJsonMixin\" ) B = TypeVar ( 'B' ) C = TypeVar ( 'C' ) Fields = List [ Tuple [ str , Any ]] class DataClassJsonMixin ( abc . ABC ): \"\"\" DataClassJsonMixin is an ABC that functions as a Mixin. As with other ABCs, it should not be instantiated directly. \"\"\" dataclass_json_config = None def to_json ( self , * , skipkeys : bool = False , ensure_ascii : bool = True , check_circular : bool = True , allow_nan : bool = True , indent : Optional [ Union [ int , str ]] = None , separators : Tuple [ str , str ] = None , default : Callable = None , sort_keys : bool = False , ** kw ) -> str : return json . dumps ( self . to_dict ( encode_json = False ), cls = _ExtendedEncoder , skipkeys = skipkeys , ensure_ascii = ensure_ascii , check_circular = check_circular , allow_nan = allow_nan , indent = indent , separators = separators , default = default , sort_keys = sort_keys , ** kw ) @classmethod def from_json ( cls : Type [ A ], s : JsonData , * , parse_float = None , parse_int = None , parse_constant = None , infer_missing = False , ** kw ) -> A : kvs = json . loads ( s , parse_float = parse_float , parse_int = parse_int , parse_constant = parse_constant , ** kw ) return cls . from_dict ( kvs , infer_missing = infer_missing ) @classmethod def from_dict ( cls : Type [ A ], kvs : Json , * , infer_missing = False ) -> A : return _decode_dataclass ( cls , kvs , infer_missing ) def to_dict ( self , encode_json = False ) -> Dict [ str , Json ]: return _asdict ( self , encode_json = encode_json ) @classmethod def schema ( cls : Type [ A ], * , infer_missing : bool = False , only = None , exclude = (), many : bool = False , context = None , load_only = (), dump_only = (), partial : bool = False , unknown = None ) -> SchemaType : Schema = build_schema ( cls , DataClassJsonMixin , infer_missing , partial ) if unknown is None : undefined_parameter_action = _undefined_parameter_action_safe ( cls ) if undefined_parameter_action is not None : # We can just make use of the same-named mm keywords unknown = undefined_parameter_action . name . lower () return Schema ( only = only , exclude = exclude , many = many , context = context , load_only = load_only , dump_only = dump_only , partial = partial , unknown = unknown ) def dataclass_json ( _cls = None , * , letter_case = None , undefined : Optional [ Union [ str , Undefined ]] = None ): \"\"\" Based on the code in the `dataclasses` module to handle optional-parens decorators. See example below: @dataclass_json @dataclass_json(letter_case=LetterCase.CAMEL) class Example: ... \"\"\" def wrap ( cls ): return _process_class ( cls , letter_case , undefined ) if _cls is None : return wrap return wrap ( _cls ) def _process_class ( cls , letter_case , undefined ): if letter_case is not None or undefined is not None : cls . dataclass_json_config = config ( letter_case = letter_case , undefined = undefined )[ 'dataclasses_json' ] cls . to_json = DataClassJsonMixin . to_json # unwrap and rewrap classmethod to tag it to cls rather than the literal # DataClassJsonMixin ABC cls . from_json = classmethod ( DataClassJsonMixin . from_json . __func__ ) cls . to_dict = DataClassJsonMixin . to_dict cls . from_dict = classmethod ( DataClassJsonMixin . from_dict . __func__ ) cls . schema = classmethod ( DataClassJsonMixin . schema . __func__ ) cls . __init__ = _handle_undefined_parameters_safe ( cls , kvs = (), usage = \"init\" ) # register cls as a virtual subclass of DataClassJsonMixin DataClassJsonMixin . register ( cls ) return cls","title":"Module dataclasses_json.api"},{"location":"reference/dataclasses_json/api/#variables","text":"A B C Fields","title":"Variables"},{"location":"reference/dataclasses_json/api/#functions","text":"","title":"Functions"},{"location":"reference/dataclasses_json/api/#dataclass_json","text":"def dataclass_json ( _cls = None , * , letter_case = None , undefined : Union [ str , dataclasses_json . undefined . Undefined , NoneType ] = None ) Based on the code in the dataclasses module to handle optional-parens decorators. See example below: @dataclass_json @dataclass_json(letter_case=LetterCase.CAMEL) class Example: ... View Source def dataclass_json ( _cls = None , * , letter_case = None , undefined : Optional [ Union [ str , Undefined ]] = None ): \"\"\" Based on the code in the `dataclasses` module to handle optional-parens decorators. See example below: @dataclass_json @dataclass_json(letter_case=LetterCase.CAMEL) class Example: ... \"\"\" def wrap ( cls ): return _process_class ( cls , letter_case , undefined ) if _cls is None : return wrap return wrap ( _cls )","title":"dataclass_json"},{"location":"reference/dataclasses_json/api/#classes","text":"","title":"Classes"},{"location":"reference/dataclasses_json/api/#dataclassjsonmixin","text":"class DataClassJsonMixin ( / , * args , ** kwargs ) DataClassJsonMixin is an ABC that functions as a Mixin. As with other ABCs, it should not be instantiated directly. View Source class DataClassJsonMixin ( abc . ABC ) : \"\"\" DataClassJsonMixin is an ABC that functions as a Mixin. As with other ABCs, it should not be instantiated directly. \"\"\" dataclass_json_config = None def to_json ( self , * , skipkeys : bool = False , ensure_ascii : bool = True , check_circular : bool = True , allow_nan : bool = True , indent : Optional [ Union[int, str ] ] = None , separators : Tuple [ str, str ] = None , default : Callable = None , sort_keys : bool = False , ** kw ) -> str : return json . dumps ( self . to_dict ( encode_json = False ), cls = _ExtendedEncoder , skipkeys = skipkeys , ensure_ascii = ensure_ascii , check_circular = check_circular , allow_nan = allow_nan , indent = indent , separators = separators , default = default , sort_keys = sort_keys , ** kw ) @classmethod def from_json ( cls : Type [ A ] , s : JsonData , * , parse_float = None , parse_int = None , parse_constant = None , infer_missing = False , ** kw ) -> A : kvs = json . loads ( s , parse_float = parse_float , parse_int = parse_int , parse_constant = parse_constant , ** kw ) return cls . from_dict ( kvs , infer_missing = infer_missing ) @classmethod def from_dict ( cls : Type [ A ] , kvs : Json , * , infer_missing = False ) -> A : return _decode_dataclass ( cls , kvs , infer_missing ) def to_dict ( self , encode_json = False ) -> Dict [ str, Json ] : return _asdict ( self , encode_json = encode_json ) @classmethod def schema ( cls : Type [ A ] , * , infer_missing : bool = False , only = None , exclude = (), many : bool = False , context = None , load_only = (), dump_only = (), partial : bool = False , unknown = None ) -> SchemaType : Schema = build_schema ( cls , DataClassJsonMixin , infer_missing , partial ) if unknown is None : undefined_parameter_action = _undefined_parameter_action_safe ( cls ) if undefined_parameter_action is not None : # We can just make use of the same - named mm keywords unknown = undefined_parameter_action . name . lower () return Schema ( only = only , exclude = exclude , many = many , context = context , load_only = load_only , dump_only = dump_only , partial = partial , unknown = unknown )","title":"DataClassJsonMixin"},{"location":"reference/dataclasses_json/api/#ancestors-in-mro","text":"abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/dataclasses_json/api/#class-variables","text":"dataclass_json_config","title":"Class variables"},{"location":"reference/dataclasses_json/api/#static-methods","text":"","title":"Static methods"},{"location":"reference/dataclasses_json/api/#from_dict","text":"def from_dict ( kvs : Union [ dict , list , str , int , float , bool , NoneType ], * , infer_missing = False ) -> ~ A View Source @classmethod def from_dict ( cls : Type [ A ] , kvs : Json , * , infer_missing = False ) -> A : return _decode_dataclass ( cls , kvs , infer_missing )","title":"from_dict"},{"location":"reference/dataclasses_json/api/#from_json","text":"def from_json ( s : Union [ str , bytes , bytearray ], * , parse_float = None , parse_int = None , parse_constant = None , infer_missing = False , ** kw ) -> ~ A View Source @classmethod def from_json ( cls : Type [ A ] , s : JsonData , * , parse_float = None , parse_int = None , parse_constant = None , infer_missing = False , ** kw ) -> A : kvs = json . loads ( s , parse_float = parse_float , parse_int = parse_int , parse_constant = parse_constant , ** kw ) return cls . from_dict ( kvs , infer_missing = infer_missing )","title":"from_json"},{"location":"reference/dataclasses_json/api/#schema","text":"def schema ( * , infer_missing : bool = False , only = None , exclude = (), many : bool = False , context = None , load_only = (), dump_only = (), partial : bool = False , unknown = None ) -> dataclasses_json . mm . SchemaF [ ~ A ] View Source @classmethod def schema ( cls : Type [ A ] , * , infer_missing : bool = False , only = None , exclude = (), many : bool = False , context = None , load_only = (), dump_only = (), partial : bool = False , unknown = None ) -> SchemaType : Schema = build_schema ( cls , DataClassJsonMixin , infer_missing , partial ) if unknown is None : undefined_parameter_action = _undefined_parameter_action_safe ( cls ) if undefined_parameter_action is not None : # We can just make use of the same - named mm keywords unknown = undefined_parameter_action . name . lower () return Schema ( only = only , exclude = exclude , many = many , context = context , load_only = load_only , dump_only = dump_only , partial = partial , unknown = unknown )","title":"schema"},{"location":"reference/dataclasses_json/api/#methods","text":"","title":"Methods"},{"location":"reference/dataclasses_json/api/#to_dict","text":"def to_dict ( self , encode_json = False ) -> Dict [ str , Union [ dict , list , str , int , float , bool , NoneType ]] View Source def to_dict ( self , encode_json = False ) -> Dict [ str , Json ]: return _asdict ( self , encode_json = encode_json )","title":"to_dict"},{"location":"reference/dataclasses_json/api/#to_json","text":"def to_json ( self , * , skipkeys : bool = False , ensure_ascii : bool = True , check_circular : bool = True , allow_nan : bool = True , indent : Union [ int , str , NoneType ] = None , separators : Tuple [ str , str ] = None , default : Callable = None , sort_keys : bool = False , ** kw ) -> str View Source def to_json ( self , * , skipkeys : bool = False , ensure_ascii : bool = True , check_circular : bool = True , allow_nan : bool = True , indent : Optional [ Union [ int , str ]] = None , separators : Tuple [ str , str ] = None , default : Callable = None , sort_keys : bool = False , ** kw ) -> str : return json . dumps ( self . to_dict ( encode_json = False ), cls = _ExtendedEncoder , skipkeys = skipkeys , ensure_ascii = ensure_ascii , check_circular = check_circular , allow_nan = allow_nan , indent = indent , separators = separators , default = default , sort_keys = sort_keys , ** kw )","title":"to_json"},{"location":"reference/dataclasses_json/cfg/","text":"Module dataclasses_json.cfg View Source import functools from enum import Enum from typing import Callable , Dict , Optional , TypeVar , Union from marshmallow.fields import Field as MarshmallowField from dataclasses_json.stringcase import ( camelcase , pascalcase , snakecase , spinalcase ) # type: ignore from dataclasses_json.undefined import Undefined , UndefinedParameterError T = TypeVar ( \"T\" ) class Exclude : \"\"\" Pre-defined constants for exclusion. By default, fields are configured to be included. \"\"\" ALWAYS : Callable [[ T ], bool ] = lambda _ : True NEVER : Callable [[ T ], bool ] = lambda _ : False # TODO: add warnings? class _GlobalConfig : def __init__ ( self ): self . encoders : Dict [ type , Callable ] = {} self . decoders : Dict [ type , Callable ] = {} self . mm_fields : Dict [ type , MarshmallowField ] = {} # self._json_module = json # TODO: #180 # @property # def json_module(self): # return self._json_module # # @json_module.setter # def json_module(self, value): # warnings.warn(f\"Now using {value.__name__} module to handle JSON. \" # f\"{self._disable_msg}\") # self._json_module = value global_config = _GlobalConfig () class LetterCase ( Enum ): CAMEL = camelcase KEBAB = spinalcase SNAKE = snakecase PASCAL = pascalcase def config ( metadata : dict = None , * , # TODO: these can be typed more precisely # Specifically, a Callable[A, B], where `B` is bound as a JSON type encoder : Callable = None , decoder : Callable = None , mm_field : MarshmallowField = None , letter_case : Union [ Callable [[ str ], str ], LetterCase , None ] = None , undefined : Optional [ Union [ str , Undefined ]] = None , field_name : str = None , exclude : Union [ Callable [[ str , T ], bool ], Exclude , None ] = None , ) -> Dict [ str , dict ]: if metadata is None : metadata = {} lib_metadata = metadata . setdefault ( 'dataclasses_json' , {}) if encoder is not None : lib_metadata [ 'encoder' ] = encoder if decoder is not None : lib_metadata [ 'decoder' ] = decoder if mm_field is not None : lib_metadata [ 'mm_field' ] = mm_field if field_name is not None : if letter_case is not None : @functools.wraps ( letter_case ) # type:ignore def override ( _ , _letter_case = letter_case , _field_name = field_name ): return _letter_case ( _field_name ) else : def override ( _ , _field_name = field_name ): # type:ignore return _field_name letter_case = override if letter_case is not None : lib_metadata [ 'letter_case' ] = letter_case if undefined is not None : # Get the corresponding action for undefined parameters if isinstance ( undefined , str ): if not hasattr ( Undefined , undefined . upper ()): valid_actions = list ( action . name for action in Undefined ) raise UndefinedParameterError ( f \"Invalid undefined parameter action, \" f \"must be one of {valid_actions}\" ) undefined = Undefined [ undefined . upper ()] lib_metadata [ 'undefined' ] = undefined if exclude is not None : lib_metadata [ 'exclude' ] = exclude return metadata Variables T global_config Functions config def config ( metadata : dict = None , * , encoder : Callable = None , decoder : Callable = None , mm_field : marshmallow . fields . Field = None , letter_case : Union [ Callable [[ str ], str ], dataclasses_json . cfg . LetterCase , NoneType ] = None , undefined : Union [ str , dataclasses_json . undefined . Undefined , NoneType ] = None , field_name : str = None , exclude : Union [ Callable [[ str , ~ T ], bool ], dataclasses_json . cfg . Exclude , NoneType ] = None ) -> Dict [ str , dict ] View Source def config ( metadata : dict = None , * , # TODO : these can be typed more precisely # Specifically , a Callable [ A, B ] , where ` B ` is bound as a JSON type encoder : Callable = None , decoder : Callable = None , mm_field : MarshmallowField = None , letter_case : Union [ Callable[[str ] , str ] , LetterCase , None ] = None , undefined : Optional [ Union[str, Undefined ] ] = None , field_name : str = None , exclude : Union [ Callable[[str, T ] , bool ] , Exclude , None ] = None , ) -> Dict [ str, dict ] : if metadata is None : metadata = {} lib_metadata = metadata . setdefault ( 'dataclasses_json' , {} ) if encoder is not None : lib_metadata [ 'encoder' ] = encoder if decoder is not None : lib_metadata [ 'decoder' ] = decoder if mm_field is not None : lib_metadata [ 'mm_field' ] = mm_field if field_name is not None : if letter_case is not None : @functools . wraps ( letter_case ) # type : ignore def override ( _ , _letter_case = letter_case , _field_name = field_name ) : return _letter_case ( _field_name ) else : def override ( _ , _field_name = field_name ) : # type : ignore return _field_name letter_case = override if letter_case is not None : lib_metadata [ 'letter_case' ] = letter_case if undefined is not None : # Get the corresponding action for undefined parameters if isinstance ( undefined , str ) : if not hasattr ( Undefined , undefined . upper ()) : valid_actions = list ( action . name for action in Undefined ) raise UndefinedParameterError ( f \"Invalid undefined parameter action, \" f \"must be one of {valid_actions}\" ) undefined = Undefined [ undefined.upper() ] lib_metadata [ 'undefined' ] = undefined if exclude is not None : lib_metadata [ 'exclude' ] = exclude return metadata Classes Exclude class Exclude ( / , * args , ** kwargs ) Pre-defined constants for exclusion. By default, fields are configured to be included. View Source class Exclude : \"\"\" Pre-defined constants for exclusion. By default, fields are configured to be included. \"\"\" ALWAYS : Callable [ [T ] , bool ] = lambda _ : True NEVER : Callable [ [T ] , bool ] = lambda _ : False Methods ALWAYS def ALWAYS ( _ ) View Source ALWAYS : Callable [ [T ] , bool ] = lambda _ : True NEVER def NEVER ( _ ) View Source NEVER : Callable [ [T ] , bool ] = lambda _ : False LetterCase class LetterCase ( / , * args , ** kwargs ) An enumeration. View Source class LetterCase ( Enum ): CAMEL = camelcase KEBAB = spinalcase SNAKE = snakecase PASCAL = pascalcase Ancestors (in MRO) enum.Enum Class variables CAMEL KEBAB PASCAL SNAKE name value","title":"Cfg"},{"location":"reference/dataclasses_json/cfg/#module-dataclasses_jsoncfg","text":"View Source import functools from enum import Enum from typing import Callable , Dict , Optional , TypeVar , Union from marshmallow.fields import Field as MarshmallowField from dataclasses_json.stringcase import ( camelcase , pascalcase , snakecase , spinalcase ) # type: ignore from dataclasses_json.undefined import Undefined , UndefinedParameterError T = TypeVar ( \"T\" ) class Exclude : \"\"\" Pre-defined constants for exclusion. By default, fields are configured to be included. \"\"\" ALWAYS : Callable [[ T ], bool ] = lambda _ : True NEVER : Callable [[ T ], bool ] = lambda _ : False # TODO: add warnings? class _GlobalConfig : def __init__ ( self ): self . encoders : Dict [ type , Callable ] = {} self . decoders : Dict [ type , Callable ] = {} self . mm_fields : Dict [ type , MarshmallowField ] = {} # self._json_module = json # TODO: #180 # @property # def json_module(self): # return self._json_module # # @json_module.setter # def json_module(self, value): # warnings.warn(f\"Now using {value.__name__} module to handle JSON. \" # f\"{self._disable_msg}\") # self._json_module = value global_config = _GlobalConfig () class LetterCase ( Enum ): CAMEL = camelcase KEBAB = spinalcase SNAKE = snakecase PASCAL = pascalcase def config ( metadata : dict = None , * , # TODO: these can be typed more precisely # Specifically, a Callable[A, B], where `B` is bound as a JSON type encoder : Callable = None , decoder : Callable = None , mm_field : MarshmallowField = None , letter_case : Union [ Callable [[ str ], str ], LetterCase , None ] = None , undefined : Optional [ Union [ str , Undefined ]] = None , field_name : str = None , exclude : Union [ Callable [[ str , T ], bool ], Exclude , None ] = None , ) -> Dict [ str , dict ]: if metadata is None : metadata = {} lib_metadata = metadata . setdefault ( 'dataclasses_json' , {}) if encoder is not None : lib_metadata [ 'encoder' ] = encoder if decoder is not None : lib_metadata [ 'decoder' ] = decoder if mm_field is not None : lib_metadata [ 'mm_field' ] = mm_field if field_name is not None : if letter_case is not None : @functools.wraps ( letter_case ) # type:ignore def override ( _ , _letter_case = letter_case , _field_name = field_name ): return _letter_case ( _field_name ) else : def override ( _ , _field_name = field_name ): # type:ignore return _field_name letter_case = override if letter_case is not None : lib_metadata [ 'letter_case' ] = letter_case if undefined is not None : # Get the corresponding action for undefined parameters if isinstance ( undefined , str ): if not hasattr ( Undefined , undefined . upper ()): valid_actions = list ( action . name for action in Undefined ) raise UndefinedParameterError ( f \"Invalid undefined parameter action, \" f \"must be one of {valid_actions}\" ) undefined = Undefined [ undefined . upper ()] lib_metadata [ 'undefined' ] = undefined if exclude is not None : lib_metadata [ 'exclude' ] = exclude return metadata","title":"Module dataclasses_json.cfg"},{"location":"reference/dataclasses_json/cfg/#variables","text":"T global_config","title":"Variables"},{"location":"reference/dataclasses_json/cfg/#functions","text":"","title":"Functions"},{"location":"reference/dataclasses_json/cfg/#config","text":"def config ( metadata : dict = None , * , encoder : Callable = None , decoder : Callable = None , mm_field : marshmallow . fields . Field = None , letter_case : Union [ Callable [[ str ], str ], dataclasses_json . cfg . LetterCase , NoneType ] = None , undefined : Union [ str , dataclasses_json . undefined . Undefined , NoneType ] = None , field_name : str = None , exclude : Union [ Callable [[ str , ~ T ], bool ], dataclasses_json . cfg . Exclude , NoneType ] = None ) -> Dict [ str , dict ] View Source def config ( metadata : dict = None , * , # TODO : these can be typed more precisely # Specifically , a Callable [ A, B ] , where ` B ` is bound as a JSON type encoder : Callable = None , decoder : Callable = None , mm_field : MarshmallowField = None , letter_case : Union [ Callable[[str ] , str ] , LetterCase , None ] = None , undefined : Optional [ Union[str, Undefined ] ] = None , field_name : str = None , exclude : Union [ Callable[[str, T ] , bool ] , Exclude , None ] = None , ) -> Dict [ str, dict ] : if metadata is None : metadata = {} lib_metadata = metadata . setdefault ( 'dataclasses_json' , {} ) if encoder is not None : lib_metadata [ 'encoder' ] = encoder if decoder is not None : lib_metadata [ 'decoder' ] = decoder if mm_field is not None : lib_metadata [ 'mm_field' ] = mm_field if field_name is not None : if letter_case is not None : @functools . wraps ( letter_case ) # type : ignore def override ( _ , _letter_case = letter_case , _field_name = field_name ) : return _letter_case ( _field_name ) else : def override ( _ , _field_name = field_name ) : # type : ignore return _field_name letter_case = override if letter_case is not None : lib_metadata [ 'letter_case' ] = letter_case if undefined is not None : # Get the corresponding action for undefined parameters if isinstance ( undefined , str ) : if not hasattr ( Undefined , undefined . upper ()) : valid_actions = list ( action . name for action in Undefined ) raise UndefinedParameterError ( f \"Invalid undefined parameter action, \" f \"must be one of {valid_actions}\" ) undefined = Undefined [ undefined.upper() ] lib_metadata [ 'undefined' ] = undefined if exclude is not None : lib_metadata [ 'exclude' ] = exclude return metadata","title":"config"},{"location":"reference/dataclasses_json/cfg/#classes","text":"","title":"Classes"},{"location":"reference/dataclasses_json/cfg/#exclude","text":"class Exclude ( / , * args , ** kwargs ) Pre-defined constants for exclusion. By default, fields are configured to be included. View Source class Exclude : \"\"\" Pre-defined constants for exclusion. By default, fields are configured to be included. \"\"\" ALWAYS : Callable [ [T ] , bool ] = lambda _ : True NEVER : Callable [ [T ] , bool ] = lambda _ : False","title":"Exclude"},{"location":"reference/dataclasses_json/cfg/#methods","text":"","title":"Methods"},{"location":"reference/dataclasses_json/cfg/#always","text":"def ALWAYS ( _ ) View Source ALWAYS : Callable [ [T ] , bool ] = lambda _ : True","title":"ALWAYS"},{"location":"reference/dataclasses_json/cfg/#never","text":"def NEVER ( _ ) View Source NEVER : Callable [ [T ] , bool ] = lambda _ : False","title":"NEVER"},{"location":"reference/dataclasses_json/cfg/#lettercase","text":"class LetterCase ( / , * args , ** kwargs ) An enumeration. View Source class LetterCase ( Enum ): CAMEL = camelcase KEBAB = spinalcase SNAKE = snakecase PASCAL = pascalcase","title":"LetterCase"},{"location":"reference/dataclasses_json/cfg/#ancestors-in-mro","text":"enum.Enum","title":"Ancestors (in MRO)"},{"location":"reference/dataclasses_json/cfg/#class-variables","text":"CAMEL KEBAB PASCAL SNAKE name value","title":"Class variables"},{"location":"reference/dataclasses_json/core/","text":"Module dataclasses_json.core View Source import copy import json import warnings from collections import defaultdict , namedtuple # noinspection PyProtectedMember from dataclasses import ( MISSING , _is_dataclass_instance , fields , is_dataclass # type: ignore ) from datetime import datetime , timezone from decimal import Decimal from enum import Enum from typing import Any , Collection , Mapping , Union , get_type_hints , Tuple from uuid import UUID from typing_inspect import is_union_type # type: ignore from dataclasses_json import cfg from dataclasses_json.utils import ( _get_type_cons , _get_type_origin , _handle_undefined_parameters_safe , _is_collection , _is_mapping , _is_new_type , _is_optional , _isinstance_safe , _issubclass_safe ) Json = Union [ dict , list , str , int , float , bool , None ] confs = [ 'encoder' , 'decoder' , 'mm_field' , 'letter_case' , 'exclude' ] FieldOverride = namedtuple ( 'FieldOverride' , confs ) class _ExtendedEncoder ( json . JSONEncoder ): def default ( self , o ) -> Json : result : Json if _isinstance_safe ( o , Collection ): if _isinstance_safe ( o , Mapping ): result = dict ( o ) else : result = list ( o ) elif _isinstance_safe ( o , datetime ): result = o . timestamp () elif _isinstance_safe ( o , UUID ): result = str ( o ) elif _isinstance_safe ( o , Enum ): result = o . value elif _isinstance_safe ( o , Decimal ): result = str ( o ) else : result = json . JSONEncoder . default ( self , o ) return result def _user_overrides_or_exts ( cls ): global_metadata = defaultdict ( dict ) encoders = cfg . global_config . encoders decoders = cfg . global_config . decoders mm_fields = cfg . global_config . mm_fields for field in fields ( cls ): if field . type in encoders : global_metadata [ field . name ][ 'encoder' ] = encoders [ field . type ] if field . type in decoders : global_metadata [ field . name ][ 'decoder' ] = decoders [ field . type ] if field . type in mm_fields : global_metadata [ field . name ][ 'mm_fields' ] = mm_fields [ field . type ] try : cls_config = ( cls . dataclass_json_config if cls . dataclass_json_config is not None else {}) except AttributeError : cls_config = {} overrides = {} for field in fields ( cls ): field_config = {} # first apply global overrides or extensions field_metadata = global_metadata [ field . name ] if 'encoder' in field_metadata : field_config [ 'encoder' ] = field_metadata [ 'encoder' ] if 'decoder' in field_metadata : field_config [ 'decoder' ] = field_metadata [ 'decoder' ] if 'mm_field' in field_metadata : field_config [ 'mm_field' ] = field_metadata [ 'mm_field' ] # then apply class-level overrides or extensions field_config . update ( cls_config ) # last apply field-level overrides or extensions field_config . update ( field . metadata . get ( 'dataclasses_json' , {})) overrides [ field . name ] = FieldOverride ( * map ( field_config . get , confs )) return overrides def _encode_json_type ( value , default = _ExtendedEncoder () . default ): if isinstance ( value , Json . __args__ ): # type: ignore return value return default ( value ) def _encode_overrides ( kvs , overrides , encode_json = False ): override_kvs = {} for k , v in kvs . items (): if k in overrides : exclude = overrides [ k ] . exclude # If the exclude predicate returns true, the key should be # excluded from encoding, so skip the rest of the loop if exclude and exclude ( v ): continue letter_case = overrides [ k ] . letter_case original_key = k k = letter_case ( k ) if letter_case is not None else k encoder = overrides [ original_key ] . encoder v = encoder ( v ) if encoder is not None else v if encode_json : v = _encode_json_type ( v ) override_kvs [ k ] = v return override_kvs def _decode_letter_case_overrides ( field_names , overrides ): \"\"\"Override letter case of field names for encode/decode\"\"\" names = {} for field_name in field_names : field_override = overrides . get ( field_name ) if field_override is not None : letter_case = field_override . letter_case if letter_case is not None : names [ letter_case ( field_name )] = field_name return names def _decode_dataclass ( cls , kvs , infer_missing ): if _isinstance_safe ( kvs , cls ): return kvs overrides = _user_overrides_or_exts ( cls ) kvs = {} if kvs is None and infer_missing else kvs field_names = [ field . name for field in fields ( cls )] decode_names = _decode_letter_case_overrides ( field_names , overrides ) kvs = { decode_names . get ( k , k ): v for k , v in kvs . items ()} missing_fields = { field for field in fields ( cls ) if field . name not in kvs } for field in missing_fields : if field . default is not MISSING : kvs [ field . name ] = field . default elif field . default_factory is not MISSING : kvs [ field . name ] = field . default_factory () elif infer_missing : kvs [ field . name ] = None # Perform undefined parameter action kvs = _handle_undefined_parameters_safe ( cls , kvs , usage = \"from\" ) init_kwargs = {} types = get_type_hints ( cls ) for field in fields ( cls ): # The field should be skipped from being added # to init_kwargs as it's not intended as a constructor argument. if not field . init : continue field_value = kvs [ field . name ] field_type = types [ field . name ] if field_value is None and not _is_optional ( field_type ): warning = ( f \"value of non-optional type {field.name} detected \" f \"when decoding {cls.__name__}\" ) if infer_missing : warnings . warn ( f \"Missing {warning} and was defaulted to None by \" f \"infer_missing=True. \" f \"Set infer_missing=False (the default) to prevent this \" f \"behavior.\" , RuntimeWarning ) else : warnings . warn ( f \"`NoneType` object {warning}.\" , RuntimeWarning ) init_kwargs [ field . name ] = field_value continue while True : if not _is_new_type ( field_type ): break field_type = field_type . __supertype__ if ( field . name in overrides and overrides [ field . name ] . decoder is not None ): # FIXME hack if field_type is type ( field_value ): init_kwargs [ field . name ] = field_value else : init_kwargs [ field . name ] = overrides [ field . name ] . decoder ( field_value ) elif is_dataclass ( field_type ): # FIXME this is a band-aid to deal with the value already being # serialized when handling nested marshmallow schema # proper fix is to investigate the marshmallow schema generation # code if is_dataclass ( field_value ): value = field_value else : value = _decode_dataclass ( field_type , field_value , infer_missing ) init_kwargs [ field . name ] = value elif _is_supported_generic ( field_type ) and field_type != str : init_kwargs [ field . name ] = _decode_generic ( field_type , field_value , infer_missing ) else : init_kwargs [ field . name ] = _support_extended_types ( field_type , field_value ) return cls ( ** init_kwargs ) def _support_extended_types ( field_type , field_value ): if _issubclass_safe ( field_type , datetime ): # FIXME this is a hack to deal with mm already decoding # the issue is we want to leverage mm fields' missing argument # but need this for the object creation hook if isinstance ( field_value , datetime ): res = field_value else : tz = datetime . now ( timezone . utc ) . astimezone () . tzinfo res = datetime . fromtimestamp ( field_value , tz = tz ) elif _issubclass_safe ( field_type , Decimal ): res = ( field_value if isinstance ( field_value , Decimal ) else Decimal ( field_value )) elif _issubclass_safe ( field_type , UUID ): res = ( field_value if isinstance ( field_value , UUID ) else UUID ( field_value )) else : res = field_value return res def _is_supported_generic ( type_ ): not_str = not _issubclass_safe ( type_ , str ) is_enum = _issubclass_safe ( type_ , Enum ) return ( not_str and _is_collection ( type_ )) or _is_optional ( type_ ) or is_union_type ( type_ ) or is_enum def _decode_generic ( type_ , value , infer_missing ): if value is None : res = value elif _issubclass_safe ( type_ , Enum ): # Convert to an Enum using the type as a constructor. # Assumes a direct match is found. res = type_ ( value ) # FIXME this is a hack to fix a deeper underlying issue. A refactor is due. elif _is_collection ( type_ ): if _is_mapping ( type_ ): k_type , v_type = getattr ( type_ , \"__args__\" , ( Any , Any )) # a mapping type has `.keys()` and `.values()` # (see collections.abc) ks = _decode_dict_keys ( k_type , value . keys (), infer_missing ) vs = _decode_items ( v_type , value . values (), infer_missing ) xs = zip ( ks , vs ) else : xs = _decode_items ( type_ . __args__ [ 0 ], value , infer_missing ) # get the constructor if using corresponding generic type in `typing` # otherwise fallback on constructing using type_ itself try : res = _get_type_cons ( type_ )( xs ) except ( TypeError , AttributeError ): res = type_ ( xs ) else : # Optional or Union if not hasattr ( type_ , \"__args__\" ): # Any, just accept res = value elif _is_optional ( type_ ) and len ( type_ . __args__ ) == 2 : # Optional type_arg = type_ . __args__ [ 0 ] if is_dataclass ( type_arg ) or is_dataclass ( value ): res = _decode_dataclass ( type_arg , value , infer_missing ) elif _is_supported_generic ( type_arg ): res = _decode_generic ( type_arg , value , infer_missing ) else : res = _support_extended_types ( type_arg , value ) else : # Union (already decoded or unsupported 'from_json' used) res = value return res def _decode_dict_keys ( key_type , xs , infer_missing ): \"\"\" Because JSON object keys must be strs, we need the extra step of decoding them back into the user's chosen python type \"\"\" decode_function = key_type # handle NoneType keys... it's weird to type a Dict as NoneType keys # but it's valid... if key_type is None or key_type == Any : decode_function = key_type = ( lambda x : x ) # handle a nested python dict that has tuples for keys. E.g. for # Dict[Tuple[int], int], key_type will be typing.Tuple[int], but # decode_function should be tuple, so map() doesn't break. # # Note: _get_type_origin() will return typing.Tuple for python # 3.6 and tuple for 3.7 and higher. elif _get_type_origin ( key_type ) in { tuple , Tuple }: decode_function = tuple key_type = key_type return map ( decode_function , _decode_items ( key_type , xs , infer_missing )) def _decode_items ( type_arg , xs , infer_missing ): \"\"\" This is a tricky situation where we need to check both the annotated type info (which is usually a type from `typing`) and check the value's type directly using `type()`. If the type_arg is a generic we can use the annotated type, but if the type_arg is a typevar we need to extract the reified type information hence the check of `is_dataclass(vs)` \"\"\" if is_dataclass ( type_arg ) or is_dataclass ( xs ): items = ( _decode_dataclass ( type_arg , x , infer_missing ) for x in xs ) elif _is_supported_generic ( type_arg ): items = ( _decode_generic ( type_arg , x , infer_missing ) for x in xs ) else : items = xs return items def _asdict ( obj , encode_json = False ): \"\"\" A re-implementation of `asdict` (based on the original in the `dataclasses` source) to support arbitrary Collection and Mapping types. \"\"\" if _is_dataclass_instance ( obj ): result = [] overrides = _user_overrides_or_exts ( obj ) for field in fields ( obj ): if overrides [ field . name ] . encoder : value = getattr ( obj , field . name ) else : value = _asdict ( getattr ( obj , field . name ), encode_json = encode_json ) result . append (( field . name , value )) result = _handle_undefined_parameters_safe ( cls = obj , kvs = dict ( result ), usage = \"to\" ) return _encode_overrides ( dict ( result ), _user_overrides_or_exts ( obj ), encode_json = encode_json ) elif isinstance ( obj , Mapping ): return dict (( _asdict ( k , encode_json = encode_json ), _asdict ( v , encode_json = encode_json )) for k , v in obj . items ()) elif isinstance ( obj , Collection ) and not isinstance ( obj , str ) \\ and not isinstance ( obj , bytes ): return list ( _asdict ( v , encode_json = encode_json ) for v in obj ) else : return copy . deepcopy ( obj ) Variables Json confs Classes FieldOverride class FieldOverride ( / , * args , ** kwargs ) FieldOverride(encoder, decoder, mm_field, letter_case, exclude) Ancestors (in MRO) builtins.tuple Class variables decoder encoder exclude letter_case mm_field Methods count def count ( self , value , / ) Return number of occurrences of value. index def index ( self , value , start = 0 , stop = 9223372036854775807 , / ) Return first index of value. Raises ValueError if the value is not present.","title":"Core"},{"location":"reference/dataclasses_json/core/#module-dataclasses_jsoncore","text":"View Source import copy import json import warnings from collections import defaultdict , namedtuple # noinspection PyProtectedMember from dataclasses import ( MISSING , _is_dataclass_instance , fields , is_dataclass # type: ignore ) from datetime import datetime , timezone from decimal import Decimal from enum import Enum from typing import Any , Collection , Mapping , Union , get_type_hints , Tuple from uuid import UUID from typing_inspect import is_union_type # type: ignore from dataclasses_json import cfg from dataclasses_json.utils import ( _get_type_cons , _get_type_origin , _handle_undefined_parameters_safe , _is_collection , _is_mapping , _is_new_type , _is_optional , _isinstance_safe , _issubclass_safe ) Json = Union [ dict , list , str , int , float , bool , None ] confs = [ 'encoder' , 'decoder' , 'mm_field' , 'letter_case' , 'exclude' ] FieldOverride = namedtuple ( 'FieldOverride' , confs ) class _ExtendedEncoder ( json . JSONEncoder ): def default ( self , o ) -> Json : result : Json if _isinstance_safe ( o , Collection ): if _isinstance_safe ( o , Mapping ): result = dict ( o ) else : result = list ( o ) elif _isinstance_safe ( o , datetime ): result = o . timestamp () elif _isinstance_safe ( o , UUID ): result = str ( o ) elif _isinstance_safe ( o , Enum ): result = o . value elif _isinstance_safe ( o , Decimal ): result = str ( o ) else : result = json . JSONEncoder . default ( self , o ) return result def _user_overrides_or_exts ( cls ): global_metadata = defaultdict ( dict ) encoders = cfg . global_config . encoders decoders = cfg . global_config . decoders mm_fields = cfg . global_config . mm_fields for field in fields ( cls ): if field . type in encoders : global_metadata [ field . name ][ 'encoder' ] = encoders [ field . type ] if field . type in decoders : global_metadata [ field . name ][ 'decoder' ] = decoders [ field . type ] if field . type in mm_fields : global_metadata [ field . name ][ 'mm_fields' ] = mm_fields [ field . type ] try : cls_config = ( cls . dataclass_json_config if cls . dataclass_json_config is not None else {}) except AttributeError : cls_config = {} overrides = {} for field in fields ( cls ): field_config = {} # first apply global overrides or extensions field_metadata = global_metadata [ field . name ] if 'encoder' in field_metadata : field_config [ 'encoder' ] = field_metadata [ 'encoder' ] if 'decoder' in field_metadata : field_config [ 'decoder' ] = field_metadata [ 'decoder' ] if 'mm_field' in field_metadata : field_config [ 'mm_field' ] = field_metadata [ 'mm_field' ] # then apply class-level overrides or extensions field_config . update ( cls_config ) # last apply field-level overrides or extensions field_config . update ( field . metadata . get ( 'dataclasses_json' , {})) overrides [ field . name ] = FieldOverride ( * map ( field_config . get , confs )) return overrides def _encode_json_type ( value , default = _ExtendedEncoder () . default ): if isinstance ( value , Json . __args__ ): # type: ignore return value return default ( value ) def _encode_overrides ( kvs , overrides , encode_json = False ): override_kvs = {} for k , v in kvs . items (): if k in overrides : exclude = overrides [ k ] . exclude # If the exclude predicate returns true, the key should be # excluded from encoding, so skip the rest of the loop if exclude and exclude ( v ): continue letter_case = overrides [ k ] . letter_case original_key = k k = letter_case ( k ) if letter_case is not None else k encoder = overrides [ original_key ] . encoder v = encoder ( v ) if encoder is not None else v if encode_json : v = _encode_json_type ( v ) override_kvs [ k ] = v return override_kvs def _decode_letter_case_overrides ( field_names , overrides ): \"\"\"Override letter case of field names for encode/decode\"\"\" names = {} for field_name in field_names : field_override = overrides . get ( field_name ) if field_override is not None : letter_case = field_override . letter_case if letter_case is not None : names [ letter_case ( field_name )] = field_name return names def _decode_dataclass ( cls , kvs , infer_missing ): if _isinstance_safe ( kvs , cls ): return kvs overrides = _user_overrides_or_exts ( cls ) kvs = {} if kvs is None and infer_missing else kvs field_names = [ field . name for field in fields ( cls )] decode_names = _decode_letter_case_overrides ( field_names , overrides ) kvs = { decode_names . get ( k , k ): v for k , v in kvs . items ()} missing_fields = { field for field in fields ( cls ) if field . name not in kvs } for field in missing_fields : if field . default is not MISSING : kvs [ field . name ] = field . default elif field . default_factory is not MISSING : kvs [ field . name ] = field . default_factory () elif infer_missing : kvs [ field . name ] = None # Perform undefined parameter action kvs = _handle_undefined_parameters_safe ( cls , kvs , usage = \"from\" ) init_kwargs = {} types = get_type_hints ( cls ) for field in fields ( cls ): # The field should be skipped from being added # to init_kwargs as it's not intended as a constructor argument. if not field . init : continue field_value = kvs [ field . name ] field_type = types [ field . name ] if field_value is None and not _is_optional ( field_type ): warning = ( f \"value of non-optional type {field.name} detected \" f \"when decoding {cls.__name__}\" ) if infer_missing : warnings . warn ( f \"Missing {warning} and was defaulted to None by \" f \"infer_missing=True. \" f \"Set infer_missing=False (the default) to prevent this \" f \"behavior.\" , RuntimeWarning ) else : warnings . warn ( f \"`NoneType` object {warning}.\" , RuntimeWarning ) init_kwargs [ field . name ] = field_value continue while True : if not _is_new_type ( field_type ): break field_type = field_type . __supertype__ if ( field . name in overrides and overrides [ field . name ] . decoder is not None ): # FIXME hack if field_type is type ( field_value ): init_kwargs [ field . name ] = field_value else : init_kwargs [ field . name ] = overrides [ field . name ] . decoder ( field_value ) elif is_dataclass ( field_type ): # FIXME this is a band-aid to deal with the value already being # serialized when handling nested marshmallow schema # proper fix is to investigate the marshmallow schema generation # code if is_dataclass ( field_value ): value = field_value else : value = _decode_dataclass ( field_type , field_value , infer_missing ) init_kwargs [ field . name ] = value elif _is_supported_generic ( field_type ) and field_type != str : init_kwargs [ field . name ] = _decode_generic ( field_type , field_value , infer_missing ) else : init_kwargs [ field . name ] = _support_extended_types ( field_type , field_value ) return cls ( ** init_kwargs ) def _support_extended_types ( field_type , field_value ): if _issubclass_safe ( field_type , datetime ): # FIXME this is a hack to deal with mm already decoding # the issue is we want to leverage mm fields' missing argument # but need this for the object creation hook if isinstance ( field_value , datetime ): res = field_value else : tz = datetime . now ( timezone . utc ) . astimezone () . tzinfo res = datetime . fromtimestamp ( field_value , tz = tz ) elif _issubclass_safe ( field_type , Decimal ): res = ( field_value if isinstance ( field_value , Decimal ) else Decimal ( field_value )) elif _issubclass_safe ( field_type , UUID ): res = ( field_value if isinstance ( field_value , UUID ) else UUID ( field_value )) else : res = field_value return res def _is_supported_generic ( type_ ): not_str = not _issubclass_safe ( type_ , str ) is_enum = _issubclass_safe ( type_ , Enum ) return ( not_str and _is_collection ( type_ )) or _is_optional ( type_ ) or is_union_type ( type_ ) or is_enum def _decode_generic ( type_ , value , infer_missing ): if value is None : res = value elif _issubclass_safe ( type_ , Enum ): # Convert to an Enum using the type as a constructor. # Assumes a direct match is found. res = type_ ( value ) # FIXME this is a hack to fix a deeper underlying issue. A refactor is due. elif _is_collection ( type_ ): if _is_mapping ( type_ ): k_type , v_type = getattr ( type_ , \"__args__\" , ( Any , Any )) # a mapping type has `.keys()` and `.values()` # (see collections.abc) ks = _decode_dict_keys ( k_type , value . keys (), infer_missing ) vs = _decode_items ( v_type , value . values (), infer_missing ) xs = zip ( ks , vs ) else : xs = _decode_items ( type_ . __args__ [ 0 ], value , infer_missing ) # get the constructor if using corresponding generic type in `typing` # otherwise fallback on constructing using type_ itself try : res = _get_type_cons ( type_ )( xs ) except ( TypeError , AttributeError ): res = type_ ( xs ) else : # Optional or Union if not hasattr ( type_ , \"__args__\" ): # Any, just accept res = value elif _is_optional ( type_ ) and len ( type_ . __args__ ) == 2 : # Optional type_arg = type_ . __args__ [ 0 ] if is_dataclass ( type_arg ) or is_dataclass ( value ): res = _decode_dataclass ( type_arg , value , infer_missing ) elif _is_supported_generic ( type_arg ): res = _decode_generic ( type_arg , value , infer_missing ) else : res = _support_extended_types ( type_arg , value ) else : # Union (already decoded or unsupported 'from_json' used) res = value return res def _decode_dict_keys ( key_type , xs , infer_missing ): \"\"\" Because JSON object keys must be strs, we need the extra step of decoding them back into the user's chosen python type \"\"\" decode_function = key_type # handle NoneType keys... it's weird to type a Dict as NoneType keys # but it's valid... if key_type is None or key_type == Any : decode_function = key_type = ( lambda x : x ) # handle a nested python dict that has tuples for keys. E.g. for # Dict[Tuple[int], int], key_type will be typing.Tuple[int], but # decode_function should be tuple, so map() doesn't break. # # Note: _get_type_origin() will return typing.Tuple for python # 3.6 and tuple for 3.7 and higher. elif _get_type_origin ( key_type ) in { tuple , Tuple }: decode_function = tuple key_type = key_type return map ( decode_function , _decode_items ( key_type , xs , infer_missing )) def _decode_items ( type_arg , xs , infer_missing ): \"\"\" This is a tricky situation where we need to check both the annotated type info (which is usually a type from `typing`) and check the value's type directly using `type()`. If the type_arg is a generic we can use the annotated type, but if the type_arg is a typevar we need to extract the reified type information hence the check of `is_dataclass(vs)` \"\"\" if is_dataclass ( type_arg ) or is_dataclass ( xs ): items = ( _decode_dataclass ( type_arg , x , infer_missing ) for x in xs ) elif _is_supported_generic ( type_arg ): items = ( _decode_generic ( type_arg , x , infer_missing ) for x in xs ) else : items = xs return items def _asdict ( obj , encode_json = False ): \"\"\" A re-implementation of `asdict` (based on the original in the `dataclasses` source) to support arbitrary Collection and Mapping types. \"\"\" if _is_dataclass_instance ( obj ): result = [] overrides = _user_overrides_or_exts ( obj ) for field in fields ( obj ): if overrides [ field . name ] . encoder : value = getattr ( obj , field . name ) else : value = _asdict ( getattr ( obj , field . name ), encode_json = encode_json ) result . append (( field . name , value )) result = _handle_undefined_parameters_safe ( cls = obj , kvs = dict ( result ), usage = \"to\" ) return _encode_overrides ( dict ( result ), _user_overrides_or_exts ( obj ), encode_json = encode_json ) elif isinstance ( obj , Mapping ): return dict (( _asdict ( k , encode_json = encode_json ), _asdict ( v , encode_json = encode_json )) for k , v in obj . items ()) elif isinstance ( obj , Collection ) and not isinstance ( obj , str ) \\ and not isinstance ( obj , bytes ): return list ( _asdict ( v , encode_json = encode_json ) for v in obj ) else : return copy . deepcopy ( obj )","title":"Module dataclasses_json.core"},{"location":"reference/dataclasses_json/core/#variables","text":"Json confs","title":"Variables"},{"location":"reference/dataclasses_json/core/#classes","text":"","title":"Classes"},{"location":"reference/dataclasses_json/core/#fieldoverride","text":"class FieldOverride ( / , * args , ** kwargs ) FieldOverride(encoder, decoder, mm_field, letter_case, exclude)","title":"FieldOverride"},{"location":"reference/dataclasses_json/core/#ancestors-in-mro","text":"builtins.tuple","title":"Ancestors (in MRO)"},{"location":"reference/dataclasses_json/core/#class-variables","text":"decoder encoder exclude letter_case mm_field","title":"Class variables"},{"location":"reference/dataclasses_json/core/#methods","text":"","title":"Methods"},{"location":"reference/dataclasses_json/core/#count","text":"def count ( self , value , / ) Return number of occurrences of value.","title":"count"},{"location":"reference/dataclasses_json/core/#index","text":"def index ( self , value , start = 0 , stop = 9223372036854775807 , / ) Return first index of value. Raises ValueError if the value is not present.","title":"index"},{"location":"reference/dataclasses_json/mm/","text":"Module dataclasses_json.mm View Source # flake8: noqa import typing import warnings import sys from copy import deepcopy from dataclasses import MISSING , is_dataclass , fields as dc_fields from datetime import datetime from decimal import Decimal from uuid import UUID from enum import Enum from typing_inspect import is_union_type # type: ignore from marshmallow import fields , Schema , post_load from marshmallow_enum import EnumField # type: ignore from marshmallow.exceptions import ValidationError from dataclasses_json.core import ( _is_supported_generic , _decode_dataclass , _ExtendedEncoder , _user_overrides_or_exts ) from dataclasses_json.utils import ( _is_collection , _is_optional , _issubclass_safe , _timestamp_to_dt_aware , _is_new_type , _get_type_origin , _handle_undefined_parameters_safe , CatchAllVar ) class _TimestampField ( fields . Field ): def _serialize ( self , value , attr , obj , ** kwargs ): if value is not None : return value . timestamp () else : if not self . required : return None else : raise ValidationError ( self . default_error_messages [ \"required\" ]) def _deserialize ( self , value , attr , data , ** kwargs ): if value is not None : return _timestamp_to_dt_aware ( value ) else : if not self . required : return None else : raise ValidationError ( self . default_error_messages [ \"required\" ]) class _IsoField ( fields . Field ): def _serialize ( self , value , attr , obj , ** kwargs ): if value is not None : return value . isoformat () else : if not self . required : return None else : raise ValidationError ( self . default_error_messages [ \"required\" ]) def _deserialize ( self , value , attr , data , ** kwargs ): if value is not None : return datetime . fromisoformat ( value ) else : if not self . required : return None else : raise ValidationError ( self . default_error_messages [ \"required\" ]) class _UnionField ( fields . Field ): def __init__ ( self , desc , cls , field , * args , ** kwargs ): self . desc = desc self . cls = cls self . field = field super () . __init__ ( * args , ** kwargs ) def _serialize ( self , value , attr , obj , ** kwargs ): if self . allow_none and value is None : return None for type_ , schema_ in self . desc . items (): if _issubclass_safe ( type ( value ), type_ ): if is_dataclass ( value ): res = schema_ . _serialize ( value , attr , obj , ** kwargs ) res [ '__type' ] = str ( type_ . __name__ ) return res break elif isinstance ( value , _get_type_origin ( type_ )): return schema_ . _serialize ( value , attr , obj , ** kwargs ) else : warnings . warn ( f 'The type \"{type(value).__name__}\" (value: \"{value}\") ' f 'is not in the list of possible types of typing.Union ' f '(dataclass: {self.cls.__name__}, field: {self.field.name}). ' f 'Value cannot be serialized properly.' ) return super () . _serialize ( value , attr , obj , ** kwargs ) def _deserialize ( self , value , attr , data , ** kwargs ): tmp_value = deepcopy ( value ) if isinstance ( tmp_value , dict ) and '__type' in tmp_value : dc_name = tmp_value [ '__type' ] for type_ , schema_ in self . desc . items (): if is_dataclass ( type_ ) and type_ . __name__ == dc_name : del tmp_value [ '__type' ] return schema_ . _deserialize ( tmp_value , attr , data , ** kwargs ) for type_ , schema_ in self . desc . items (): if isinstance ( tmp_value , _get_type_origin ( type_ )): return schema_ . _deserialize ( tmp_value , attr , data , ** kwargs ) else : warnings . warn ( f 'The type \"{type(tmp_value).__name__}\" (value: \"{tmp_value}\") ' f 'is not in the list of possible types of typing.Union ' f '(dataclass: {self.cls.__name__}, field: {self.field.name}). ' f 'Value cannot be deserialized properly.' ) return super () . _deserialize ( tmp_value , attr , data , ** kwargs ) TYPES = { typing . Mapping : fields . Mapping , typing . MutableMapping : fields . Mapping , typing . List : fields . List , typing . Dict : fields . Dict , typing . Tuple : fields . Tuple , typing . Callable : fields . Function , typing . Any : fields . Raw , dict : fields . Dict , list : fields . List , tuple : fields . Tuple , str : fields . Str , int : fields . Int , float : fields . Float , bool : fields . Bool , datetime : _TimestampField , UUID : fields . UUID , Decimal : fields . Decimal , CatchAllVar : fields . Dict , } A = typing . TypeVar ( 'A' ) JsonData = typing . Union [ str , bytes , bytearray ] TEncoded = typing . Dict [ str , typing . Any ] TOneOrMulti = typing . Union [ typing . List [ A ], A ] TOneOrMultiEncoded = typing . Union [ typing . List [ TEncoded ], TEncoded ] if sys . version_info >= ( 3 , 7 ): class SchemaF ( Schema , typing . Generic [ A ]): \"\"\"Lift Schema into a type constructor\"\"\" def __init__ ( self , * args , ** kwargs ): \"\"\" Raises exception because this class should not be inherited. This class is helper only. \"\"\" super () . __init__ ( * args , ** kwargs ) raise NotImplementedError () @typing.overload def dump ( self , obj : typing . List [ A ], many : bool = None ) -> typing . List [ TEncoded ]: # type: ignore # mm has the wrong return type annotation (dict) so we can ignore the mypy error pass @typing.overload def dump ( self , obj : A , many : bool = None ) -> TEncoded : pass def dump ( self , obj : TOneOrMulti , many : bool = None ) -> TOneOrMultiEncoded : pass @typing.overload def dumps ( self , obj : typing . List [ A ], many : bool = None , * args , ** kwargs ) -> str : pass @typing.overload def dumps ( self , obj : A , many : bool = None , * args , ** kwargs ) -> str : pass def dumps ( self , obj : TOneOrMulti , many : bool = None , * args , ** kwargs ) -> str : pass @typing.overload # type: ignore def load ( self , data : typing . List [ TEncoded ], many : bool = True , partial : bool = None , unknown : str = None ) -> \\ typing . List [ A ]: # ignore the mypy error of the decorator because mm does not define lists as an allowed input type pass @typing.overload def load ( self , data : TEncoded , many : None = None , partial : bool = None , unknown : str = None ) -> A : pass def load ( self , data : TOneOrMultiEncoded , many : bool = None , partial : bool = None , unknown : str = None ) -> TOneOrMulti : pass @typing.overload # type: ignore def loads ( self , json_data : JsonData , # type: ignore many : bool = True , partial : bool = None , unknown : str = None , ** kwargs ) -> typing . List [ A ]: # ignore the mypy error of the decorator because mm does not define bytes as correct input data # mm has the wrong return type annotation (dict) so we can ignore the mypy error # for the return type overlap pass @typing.overload def loads ( self , json_data : JsonData , many : None = None , partial : bool = None , unknown : str = None , ** kwargs ) -> A : pass def loads ( self , json_data : JsonData , many : bool = None , partial : bool = None , unknown : str = None , ** kwargs ) -> TOneOrMulti : pass SchemaType = SchemaF [ A ] else : SchemaType = Schema def build_type ( type_ , options , mixin , field , cls ): def inner ( type_ , options ): while True : if not _is_new_type ( type_ ): break type_ = type_ . __supertype__ if is_dataclass ( type_ ): if _issubclass_safe ( type_ , mixin ): options [ 'field_many' ] = bool ( _is_supported_generic ( field . type ) and _is_collection ( field . type )) return fields . Nested ( type_ . schema (), ** options ) else : warnings . warn ( f \"Nested dataclass field {field.name} of type \" f \"{field.type} detected in \" f \"{cls.__name__} that is not an instance of \" f \"dataclass_json. Did you mean to recursively \" f \"serialize this field? If so, make sure to \" f \"augment {type_} with either the \" f \"`dataclass_json` decorator or mixin.\" ) return fields . Field ( ** options ) origin = getattr ( type_ , '__origin__' , type_ ) args = [ inner ( a , {}) for a in getattr ( type_ , '__args__' , []) if a is not type ( None )] if _is_optional ( type_ ): options [ \"allow_none\" ] = True if origin in TYPES : return TYPES [ origin ]( * args , ** options ) if _issubclass_safe ( origin , Enum ): return EnumField ( enum = origin , by_value = True , * args , ** options ) if is_union_type ( type_ ): union_types = [ a for a in getattr ( type_ , '__args__' , []) if a is not type ( None )] union_desc = dict ( zip ( union_types , args )) return _UnionField ( union_desc , cls , field , ** options ) warnings . warn ( f \"Unknown type {type_} at {cls.__name__}.{field.name}: {field.type} \" f \"It's advised to pass the correct marshmallow type to `mm_field`.\" ) return fields . Field ( ** options ) return inner ( type_ , options ) def schema ( cls , mixin , infer_missing ): schema = {} overrides = _user_overrides_or_exts ( cls ) # TODO check the undefined parameters and add the proper schema action # https://marshmallow.readthedocs.io/en/stable/quickstart.html for field in dc_fields ( cls ): metadata = ( field . metadata or {}) . get ( 'dataclasses_json' , {}) metadata = overrides [ field . name ] if metadata . mm_field is not None : schema [ field . name ] = metadata . mm_field else : type_ = field . type options = {} missing_key = 'missing' if infer_missing else 'default' if field . default is not MISSING : options [ missing_key ] = field . default elif field . default_factory is not MISSING : options [ missing_key ] = field . default_factory if options . get ( missing_key , ... ) is None : options [ 'allow_none' ] = True if _is_optional ( type_ ): options . setdefault ( missing_key , None ) options [ 'allow_none' ] = True if len ( type_ . __args__ ) == 2 : # Union[str, int, None] is optional too, but it has more than 1 typed field. type_ = type_ . __args__ [ 0 ] if metadata . letter_case is not None : options [ 'data_key' ] = metadata . letter_case ( field . name ) t = build_type ( type_ , options , mixin , field , cls ) # if type(t) is not fields.Field: # If we use `isinstance` we would return nothing. if field . type != typing . Optional [ CatchAllVar ]: schema [ field . name ] = t return schema def build_schema ( cls : typing . Type [ A ], mixin , infer_missing , partial ) -> typing . Type [ SchemaType ]: Meta = type ( 'Meta' , (), { 'fields' : tuple ( field . name for field in dc_fields ( cls ) if field . name != 'dataclass_json_config' and field . type != typing . Optional [ CatchAllVar ]), # TODO #180 # 'render_module': global_config.json_module }) @post_load def make_instance ( self , kvs , ** kwargs ): return _decode_dataclass ( cls , kvs , partial ) def dumps ( self , * args , ** kwargs ): if 'cls' not in kwargs : kwargs [ 'cls' ] = _ExtendedEncoder return Schema . dumps ( self , * args , ** kwargs ) def dump ( self , obj , * , many = None ): many = self . many if many is None else bool ( many ) dumped = Schema . dump ( self , obj , many = many ) # TODO This is hacky, but the other option I can think of is to generate a different schema # depending on dump and load, which is even more hacky # The only problem is the catch all field, we can't statically create a schema for it # so we just update the dumped dict if many : for i , _obj in enumerate ( obj ): dumped [ i ] . update ( _handle_undefined_parameters_safe ( cls = _obj , kvs = {}, usage = \"dump\" )) else : dumped . update ( _handle_undefined_parameters_safe ( cls = obj , kvs = {}, usage = \"dump\" )) return dumped schema_ = schema ( cls , mixin , infer_missing ) DataClassSchema : typing . Type [ SchemaType ] = type ( f '{cls.__name__.capitalize()}Schema' , ( Schema ,), { 'Meta' : Meta , f 'make_{cls.__name__.lower()}' : make_instance , 'dumps' : dumps , 'dump' : dump , ** schema_ }) return DataClassSchema Variables A JsonData SchemaType TEncoded TOneOrMulti TOneOrMultiEncoded TYPES Functions build_schema def build_schema ( cls : Type [ ~ A ], mixin , infer_missing , partial ) -> Type [ dataclasses_json . mm . SchemaF [ ~ A ]] View Source def build_schema ( cls : typing . Type [ A ] , mixin , infer_missing , partial ) -> typing . Type [ SchemaType ] : Meta = type ( 'Meta' , (), { 'fields' : tuple ( field . name for field in dc_fields ( cls ) if field . name != 'dataclass_json_config' and field . type != typing . Optional [ CatchAllVar ] ), # TODO #180 # 'render_module' : global_config . json_module } ) @post_load def make_instance ( self , kvs , ** kwargs ) : return _decode_dataclass ( cls , kvs , partial ) def dumps ( self , * args , ** kwargs ) : if 'cls' not in kwargs : kwargs [ 'cls' ] = _ExtendedEncoder return Schema . dumps ( self , * args , ** kwargs ) def dump ( self , obj , * , many = None ) : many = self . many if many is None else bool ( many ) dumped = Schema . dump ( self , obj , many = many ) # TODO This is hacky , but the other option I can think of is to generate a different schema # depending on dump and load , which is even more hacky # The only problem is the catch all field , we can 't statically create a schema for it # so we just update the dumped dict if many: for i, _obj in enumerate(obj): dumped[i].update( _handle_undefined_parameters_safe(cls=_obj, kvs={}, usage=\"dump\")) else: dumped.update(_handle_undefined_parameters_safe(cls=obj, kvs={}, usage=\"dump\")) return dumped schema_ = schema(cls, mixin, infer_missing) DataClassSchema: typing.Type[SchemaType] = type( f' { cls . __name__ . capitalize () } Schema ', (Schema,), {' Meta ': Meta, f' make_ { cls . __name__ . lower () } ': make_instance, ' dumps ': dumps, ' dump ': dump , ** schema_ } ) return DataClassSchema build_type def build_type ( type_ , options , mixin , field , cls ) View Source def build_type ( type_ , options , mixin , field , cls ): def inner ( type_ , options ): while True : if not _is_new_type ( type_ ): break type_ = type_ . __supertype__ if is_dataclass ( type_ ): if _issubclass_safe ( type_ , mixin ): options [ 'field_many' ] = bool ( _is_supported_generic ( field . type ) and _is_collection ( field . type )) return fields . Nested ( type_ . schema (), ** options ) else : warnings . warn ( f \"Nested dataclass field {field.name} of type \" f \"{field.type} detected in \" f \"{cls.__name__} that is not an instance of \" f \"dataclass_json. Did you mean to recursively \" f \"serialize this field? If so, make sure to \" f \"augment {type_} with either the \" f \"`dataclass_json` decorator or mixin.\" ) return fields . Field ( ** options ) origin = getattr ( type_ , '__origin__' , type_ ) args = [ inner ( a , {} ) for a in getattr ( type_ , '__args__' , []) if a is not type ( None )] if _is_optional ( type_ ): options [ \"allow_none\" ] = True if origin in TYPES : return TYPES [ origin ]( * args , ** options ) if _issubclass_safe ( origin , Enum ): return EnumField ( enum = origin , by_value = True , * args , ** options ) if is_union_type ( type_ ): union_types = [ a for a in getattr ( type_ , '__args__' , []) if a is not type ( None )] union_desc = dict ( zip ( union_types , args )) return _UnionField ( union_desc , cls , field , ** options ) warnings . warn ( f \"Unknown type {type_} at {cls.__name__}.{field.name}: {field.type} \" f \"It's advised to pass the correct marshmallow type to `mm_field`.\" ) return fields . Field ( ** options ) return inner ( type_ , options ) schema def schema ( cls , mixin , infer_missing ) View Source def schema ( cls , mixin , infer_missing ) : schema = {} overrides = _user_overrides_or_exts ( cls ) # TODO check the undefined parameters and add the proper schema action # https : // marshmallow . readthedocs . io / en / stable / quickstart . html for field in dc_fields ( cls ) : metadata = ( field . metadata or {} ). get ( 'dataclasses_json' , {} ) metadata = overrides [ field.name ] if metadata . mm_field is not None : schema [ field.name ] = metadata . mm_field else : type_ = field . type options = {} missing_key = 'missing' if infer_missing else 'default' if field . default is not MISSING : options [ missing_key ] = field . default elif field . default_factory is not MISSING : options [ missing_key ] = field . default_factory if options . get ( missing_key , ...) is None : options [ 'allow_none' ] = True if _is_optional ( type_ ) : options . setdefault ( missing_key , None ) options [ 'allow_none' ] = True if len ( type_ . __args__ ) == 2 : # Union [ str, int, None ] is optional too , but it has more than 1 typed field . type_ = type_ . __args__ [ 0 ] if metadata . letter_case is not None : options [ 'data_key' ] = metadata . letter_case ( field . name ) t = build_type ( type_ , options , mixin , field , cls ) # if type ( t ) is not fields . Field : # If we use ` isinstance ` we would return nothing . if field . type != typing . Optional [ CatchAllVar ] : schema [ field.name ] = t return schema Classes SchemaF class SchemaF ( * args , ** kwargs ) Lift Schema into a type constructor View Source class SchemaF ( Schema , typing . Generic [ A ] ) : \"\"\"Lift Schema into a type constructor\"\"\" def __init__ ( self , * args , ** kwargs ) : \"\"\" Raises exception because this class should not be inherited. This class is helper only. \"\"\" super (). __init__ ( * args , ** kwargs ) raise NotImplementedError () @typing . overload def dump ( self , obj : typing . List [ A ] , many : bool = None ) -> typing . List [ TEncoded ] : # type : ignore # mm has the wrong return type annotation ( dict ) so we can ignore the mypy error pass @typing . overload def dump ( self , obj : A , many : bool = None ) -> TEncoded : pass def dump ( self , obj : TOneOrMulti , many : bool = None ) -> TOneOrMultiEncoded : pass @typing . overload def dumps ( self , obj : typing . List [ A ] , many : bool = None , * args , ** kwargs ) -> str : pass @typing . overload def dumps ( self , obj : A , many : bool = None , * args , ** kwargs ) -> str : pass def dumps ( self , obj : TOneOrMulti , many : bool = None , * args , ** kwargs ) -> str : pass @typing . overload # type : ignore def load ( self , data : typing . List [ TEncoded ] , many : bool = True , partial : bool = None , unknown : str = None ) -> \\ typing . List [ A ] : # ignore the mypy error of the decorator because mm does not define lists as an allowed input type pass @typing . overload def load ( self , data : TEncoded , many : None = None , partial : bool = None , unknown : str = None ) -> A : pass def load ( self , data : TOneOrMultiEncoded , many : bool = None , partial : bool = None , unknown : str = None ) -> TOneOrMulti : pass @typing . overload # type : ignore def loads ( self , json_data : JsonData , # type : ignore many : bool = True , partial : bool = None , unknown : str = None , ** kwargs ) -> typing . List [ A ] : # ignore the mypy error of the decorator because mm does not define bytes as correct input data # mm has the wrong return type annotation ( dict ) so we can ignore the mypy error # for the return type overlap pass @typing . overload def loads ( self , json_data : JsonData , many : None = None , partial : bool = None , unknown : str = None , ** kwargs ) -> A : pass def loads ( self , json_data : JsonData , many : bool = None , partial : bool = None , unknown : str = None , ** kwargs ) -> TOneOrMulti : pass Ancestors (in MRO) marshmallow.schema.Schema marshmallow.base.SchemaABC typing.Generic Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages opts Static methods from_dict def from_dict ( fields : Dict [ str , Union [ marshmallow . fields . Field , type ]], * , name : str = 'GeneratedSchema' ) -> type Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 View Source @classmethod def from_dict ( cls , fields : typing . Dict [ str , typing . Union [ ma_fields . Field , type ]], * , name : str = \"GeneratedSchema\" ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class set_class Methods dump def dump ( self , obj : Union [ List [ ~ A ], ~ A ], many : bool = None ) -> Union [ List [ Dict [ str , Any ]], Dict [ str , Any ]] Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize obj as a collection. If None , the value for self.many is used. :return: A dict of serialized data :rtype: dict .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : TOneOrMulti , many : bool = None ) -> TOneOrMultiEncoded : pass dumps def dumps ( self , obj : Union [ List [ ~ A ], ~ A ], many : bool = None , * args , ** kwargs ) -> str Same as :meth: dump , except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize obj as a collection. If None , the value for self.many is used. :return: A json string :rtype: str .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : TOneOrMulti , many : bool = None , * args , ** kwargs ) -> str : pass get_attribute def get_attribute ( self , obj : Any , attr : str , default : Any ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ): \"\"\"Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\"\" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : marshmallow . exceptions . ValidationError , data : Any , * , many : bool , ** kwargs ) Custom error handler function for the schema. :param error: The ValidationError raised during (de)serialization. :param data: The original input data. :param many: Value of many on dump or load. :param partial: Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ): \"\"\"Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\"\" pass load def load ( self , data : Union [ List [ Dict [ str , Any ]], Dict [ str , Any ]], many : bool = None , partial : bool = None , unknown : str = None ) -> Union [ List [ ~ A ], ~ A ] Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize data as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : TOneOrMultiEncoded , many : bool = None , partial : bool = None , unknown : str = None ) -> TOneOrMulti : pass loads def loads ( self , json_data : Union [ str , bytes , bytearray ], many : bool = None , partial : bool = None , unknown : str = None , ** kwargs ) -> Union [ List [ ~ A ], ~ A ] Same as :meth: load , except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize obj as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : JsonData , many : bool = None , partial : bool = None , unknown : str = None , ** kwargs ) -> TOneOrMulti : pass on_bind_field def on_bind_field ( self , field_name : str , field_obj : marshmallow . fields . Field ) -> None Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \"\"\"Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\"\" return None validate def validate ( self , data : Mapping , * , many : bool = None , partial : Union [ bool , Sequence [ str ], Set [ str ]] = None ) -> Dict [ str , List [ str ]] Validate data against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate data as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : typing . Mapping , * , many : bool = None , partial : typing . Union [ bool , types . StrSequenceOrSet ] = None ) -> typing . Dict [ str , typing . List [ str ]]: \"\"\"Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\"\" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]], exc . messages ) return {}","title":"Mm"},{"location":"reference/dataclasses_json/mm/#module-dataclasses_jsonmm","text":"View Source # flake8: noqa import typing import warnings import sys from copy import deepcopy from dataclasses import MISSING , is_dataclass , fields as dc_fields from datetime import datetime from decimal import Decimal from uuid import UUID from enum import Enum from typing_inspect import is_union_type # type: ignore from marshmallow import fields , Schema , post_load from marshmallow_enum import EnumField # type: ignore from marshmallow.exceptions import ValidationError from dataclasses_json.core import ( _is_supported_generic , _decode_dataclass , _ExtendedEncoder , _user_overrides_or_exts ) from dataclasses_json.utils import ( _is_collection , _is_optional , _issubclass_safe , _timestamp_to_dt_aware , _is_new_type , _get_type_origin , _handle_undefined_parameters_safe , CatchAllVar ) class _TimestampField ( fields . Field ): def _serialize ( self , value , attr , obj , ** kwargs ): if value is not None : return value . timestamp () else : if not self . required : return None else : raise ValidationError ( self . default_error_messages [ \"required\" ]) def _deserialize ( self , value , attr , data , ** kwargs ): if value is not None : return _timestamp_to_dt_aware ( value ) else : if not self . required : return None else : raise ValidationError ( self . default_error_messages [ \"required\" ]) class _IsoField ( fields . Field ): def _serialize ( self , value , attr , obj , ** kwargs ): if value is not None : return value . isoformat () else : if not self . required : return None else : raise ValidationError ( self . default_error_messages [ \"required\" ]) def _deserialize ( self , value , attr , data , ** kwargs ): if value is not None : return datetime . fromisoformat ( value ) else : if not self . required : return None else : raise ValidationError ( self . default_error_messages [ \"required\" ]) class _UnionField ( fields . Field ): def __init__ ( self , desc , cls , field , * args , ** kwargs ): self . desc = desc self . cls = cls self . field = field super () . __init__ ( * args , ** kwargs ) def _serialize ( self , value , attr , obj , ** kwargs ): if self . allow_none and value is None : return None for type_ , schema_ in self . desc . items (): if _issubclass_safe ( type ( value ), type_ ): if is_dataclass ( value ): res = schema_ . _serialize ( value , attr , obj , ** kwargs ) res [ '__type' ] = str ( type_ . __name__ ) return res break elif isinstance ( value , _get_type_origin ( type_ )): return schema_ . _serialize ( value , attr , obj , ** kwargs ) else : warnings . warn ( f 'The type \"{type(value).__name__}\" (value: \"{value}\") ' f 'is not in the list of possible types of typing.Union ' f '(dataclass: {self.cls.__name__}, field: {self.field.name}). ' f 'Value cannot be serialized properly.' ) return super () . _serialize ( value , attr , obj , ** kwargs ) def _deserialize ( self , value , attr , data , ** kwargs ): tmp_value = deepcopy ( value ) if isinstance ( tmp_value , dict ) and '__type' in tmp_value : dc_name = tmp_value [ '__type' ] for type_ , schema_ in self . desc . items (): if is_dataclass ( type_ ) and type_ . __name__ == dc_name : del tmp_value [ '__type' ] return schema_ . _deserialize ( tmp_value , attr , data , ** kwargs ) for type_ , schema_ in self . desc . items (): if isinstance ( tmp_value , _get_type_origin ( type_ )): return schema_ . _deserialize ( tmp_value , attr , data , ** kwargs ) else : warnings . warn ( f 'The type \"{type(tmp_value).__name__}\" (value: \"{tmp_value}\") ' f 'is not in the list of possible types of typing.Union ' f '(dataclass: {self.cls.__name__}, field: {self.field.name}). ' f 'Value cannot be deserialized properly.' ) return super () . _deserialize ( tmp_value , attr , data , ** kwargs ) TYPES = { typing . Mapping : fields . Mapping , typing . MutableMapping : fields . Mapping , typing . List : fields . List , typing . Dict : fields . Dict , typing . Tuple : fields . Tuple , typing . Callable : fields . Function , typing . Any : fields . Raw , dict : fields . Dict , list : fields . List , tuple : fields . Tuple , str : fields . Str , int : fields . Int , float : fields . Float , bool : fields . Bool , datetime : _TimestampField , UUID : fields . UUID , Decimal : fields . Decimal , CatchAllVar : fields . Dict , } A = typing . TypeVar ( 'A' ) JsonData = typing . Union [ str , bytes , bytearray ] TEncoded = typing . Dict [ str , typing . Any ] TOneOrMulti = typing . Union [ typing . List [ A ], A ] TOneOrMultiEncoded = typing . Union [ typing . List [ TEncoded ], TEncoded ] if sys . version_info >= ( 3 , 7 ): class SchemaF ( Schema , typing . Generic [ A ]): \"\"\"Lift Schema into a type constructor\"\"\" def __init__ ( self , * args , ** kwargs ): \"\"\" Raises exception because this class should not be inherited. This class is helper only. \"\"\" super () . __init__ ( * args , ** kwargs ) raise NotImplementedError () @typing.overload def dump ( self , obj : typing . List [ A ], many : bool = None ) -> typing . List [ TEncoded ]: # type: ignore # mm has the wrong return type annotation (dict) so we can ignore the mypy error pass @typing.overload def dump ( self , obj : A , many : bool = None ) -> TEncoded : pass def dump ( self , obj : TOneOrMulti , many : bool = None ) -> TOneOrMultiEncoded : pass @typing.overload def dumps ( self , obj : typing . List [ A ], many : bool = None , * args , ** kwargs ) -> str : pass @typing.overload def dumps ( self , obj : A , many : bool = None , * args , ** kwargs ) -> str : pass def dumps ( self , obj : TOneOrMulti , many : bool = None , * args , ** kwargs ) -> str : pass @typing.overload # type: ignore def load ( self , data : typing . List [ TEncoded ], many : bool = True , partial : bool = None , unknown : str = None ) -> \\ typing . List [ A ]: # ignore the mypy error of the decorator because mm does not define lists as an allowed input type pass @typing.overload def load ( self , data : TEncoded , many : None = None , partial : bool = None , unknown : str = None ) -> A : pass def load ( self , data : TOneOrMultiEncoded , many : bool = None , partial : bool = None , unknown : str = None ) -> TOneOrMulti : pass @typing.overload # type: ignore def loads ( self , json_data : JsonData , # type: ignore many : bool = True , partial : bool = None , unknown : str = None , ** kwargs ) -> typing . List [ A ]: # ignore the mypy error of the decorator because mm does not define bytes as correct input data # mm has the wrong return type annotation (dict) so we can ignore the mypy error # for the return type overlap pass @typing.overload def loads ( self , json_data : JsonData , many : None = None , partial : bool = None , unknown : str = None , ** kwargs ) -> A : pass def loads ( self , json_data : JsonData , many : bool = None , partial : bool = None , unknown : str = None , ** kwargs ) -> TOneOrMulti : pass SchemaType = SchemaF [ A ] else : SchemaType = Schema def build_type ( type_ , options , mixin , field , cls ): def inner ( type_ , options ): while True : if not _is_new_type ( type_ ): break type_ = type_ . __supertype__ if is_dataclass ( type_ ): if _issubclass_safe ( type_ , mixin ): options [ 'field_many' ] = bool ( _is_supported_generic ( field . type ) and _is_collection ( field . type )) return fields . Nested ( type_ . schema (), ** options ) else : warnings . warn ( f \"Nested dataclass field {field.name} of type \" f \"{field.type} detected in \" f \"{cls.__name__} that is not an instance of \" f \"dataclass_json. Did you mean to recursively \" f \"serialize this field? If so, make sure to \" f \"augment {type_} with either the \" f \"`dataclass_json` decorator or mixin.\" ) return fields . Field ( ** options ) origin = getattr ( type_ , '__origin__' , type_ ) args = [ inner ( a , {}) for a in getattr ( type_ , '__args__' , []) if a is not type ( None )] if _is_optional ( type_ ): options [ \"allow_none\" ] = True if origin in TYPES : return TYPES [ origin ]( * args , ** options ) if _issubclass_safe ( origin , Enum ): return EnumField ( enum = origin , by_value = True , * args , ** options ) if is_union_type ( type_ ): union_types = [ a for a in getattr ( type_ , '__args__' , []) if a is not type ( None )] union_desc = dict ( zip ( union_types , args )) return _UnionField ( union_desc , cls , field , ** options ) warnings . warn ( f \"Unknown type {type_} at {cls.__name__}.{field.name}: {field.type} \" f \"It's advised to pass the correct marshmallow type to `mm_field`.\" ) return fields . Field ( ** options ) return inner ( type_ , options ) def schema ( cls , mixin , infer_missing ): schema = {} overrides = _user_overrides_or_exts ( cls ) # TODO check the undefined parameters and add the proper schema action # https://marshmallow.readthedocs.io/en/stable/quickstart.html for field in dc_fields ( cls ): metadata = ( field . metadata or {}) . get ( 'dataclasses_json' , {}) metadata = overrides [ field . name ] if metadata . mm_field is not None : schema [ field . name ] = metadata . mm_field else : type_ = field . type options = {} missing_key = 'missing' if infer_missing else 'default' if field . default is not MISSING : options [ missing_key ] = field . default elif field . default_factory is not MISSING : options [ missing_key ] = field . default_factory if options . get ( missing_key , ... ) is None : options [ 'allow_none' ] = True if _is_optional ( type_ ): options . setdefault ( missing_key , None ) options [ 'allow_none' ] = True if len ( type_ . __args__ ) == 2 : # Union[str, int, None] is optional too, but it has more than 1 typed field. type_ = type_ . __args__ [ 0 ] if metadata . letter_case is not None : options [ 'data_key' ] = metadata . letter_case ( field . name ) t = build_type ( type_ , options , mixin , field , cls ) # if type(t) is not fields.Field: # If we use `isinstance` we would return nothing. if field . type != typing . Optional [ CatchAllVar ]: schema [ field . name ] = t return schema def build_schema ( cls : typing . Type [ A ], mixin , infer_missing , partial ) -> typing . Type [ SchemaType ]: Meta = type ( 'Meta' , (), { 'fields' : tuple ( field . name for field in dc_fields ( cls ) if field . name != 'dataclass_json_config' and field . type != typing . Optional [ CatchAllVar ]), # TODO #180 # 'render_module': global_config.json_module }) @post_load def make_instance ( self , kvs , ** kwargs ): return _decode_dataclass ( cls , kvs , partial ) def dumps ( self , * args , ** kwargs ): if 'cls' not in kwargs : kwargs [ 'cls' ] = _ExtendedEncoder return Schema . dumps ( self , * args , ** kwargs ) def dump ( self , obj , * , many = None ): many = self . many if many is None else bool ( many ) dumped = Schema . dump ( self , obj , many = many ) # TODO This is hacky, but the other option I can think of is to generate a different schema # depending on dump and load, which is even more hacky # The only problem is the catch all field, we can't statically create a schema for it # so we just update the dumped dict if many : for i , _obj in enumerate ( obj ): dumped [ i ] . update ( _handle_undefined_parameters_safe ( cls = _obj , kvs = {}, usage = \"dump\" )) else : dumped . update ( _handle_undefined_parameters_safe ( cls = obj , kvs = {}, usage = \"dump\" )) return dumped schema_ = schema ( cls , mixin , infer_missing ) DataClassSchema : typing . Type [ SchemaType ] = type ( f '{cls.__name__.capitalize()}Schema' , ( Schema ,), { 'Meta' : Meta , f 'make_{cls.__name__.lower()}' : make_instance , 'dumps' : dumps , 'dump' : dump , ** schema_ }) return DataClassSchema","title":"Module dataclasses_json.mm"},{"location":"reference/dataclasses_json/mm/#variables","text":"A JsonData SchemaType TEncoded TOneOrMulti TOneOrMultiEncoded TYPES","title":"Variables"},{"location":"reference/dataclasses_json/mm/#functions","text":"","title":"Functions"},{"location":"reference/dataclasses_json/mm/#build_schema","text":"def build_schema ( cls : Type [ ~ A ], mixin , infer_missing , partial ) -> Type [ dataclasses_json . mm . SchemaF [ ~ A ]] View Source def build_schema ( cls : typing . Type [ A ] , mixin , infer_missing , partial ) -> typing . Type [ SchemaType ] : Meta = type ( 'Meta' , (), { 'fields' : tuple ( field . name for field in dc_fields ( cls ) if field . name != 'dataclass_json_config' and field . type != typing . Optional [ CatchAllVar ] ), # TODO #180 # 'render_module' : global_config . json_module } ) @post_load def make_instance ( self , kvs , ** kwargs ) : return _decode_dataclass ( cls , kvs , partial ) def dumps ( self , * args , ** kwargs ) : if 'cls' not in kwargs : kwargs [ 'cls' ] = _ExtendedEncoder return Schema . dumps ( self , * args , ** kwargs ) def dump ( self , obj , * , many = None ) : many = self . many if many is None else bool ( many ) dumped = Schema . dump ( self , obj , many = many ) # TODO This is hacky , but the other option I can think of is to generate a different schema # depending on dump and load , which is even more hacky # The only problem is the catch all field , we can 't statically create a schema for it # so we just update the dumped dict if many: for i, _obj in enumerate(obj): dumped[i].update( _handle_undefined_parameters_safe(cls=_obj, kvs={}, usage=\"dump\")) else: dumped.update(_handle_undefined_parameters_safe(cls=obj, kvs={}, usage=\"dump\")) return dumped schema_ = schema(cls, mixin, infer_missing) DataClassSchema: typing.Type[SchemaType] = type( f' { cls . __name__ . capitalize () } Schema ', (Schema,), {' Meta ': Meta, f' make_ { cls . __name__ . lower () } ': make_instance, ' dumps ': dumps, ' dump ': dump , ** schema_ } ) return DataClassSchema","title":"build_schema"},{"location":"reference/dataclasses_json/mm/#build_type","text":"def build_type ( type_ , options , mixin , field , cls ) View Source def build_type ( type_ , options , mixin , field , cls ): def inner ( type_ , options ): while True : if not _is_new_type ( type_ ): break type_ = type_ . __supertype__ if is_dataclass ( type_ ): if _issubclass_safe ( type_ , mixin ): options [ 'field_many' ] = bool ( _is_supported_generic ( field . type ) and _is_collection ( field . type )) return fields . Nested ( type_ . schema (), ** options ) else : warnings . warn ( f \"Nested dataclass field {field.name} of type \" f \"{field.type} detected in \" f \"{cls.__name__} that is not an instance of \" f \"dataclass_json. Did you mean to recursively \" f \"serialize this field? If so, make sure to \" f \"augment {type_} with either the \" f \"`dataclass_json` decorator or mixin.\" ) return fields . Field ( ** options ) origin = getattr ( type_ , '__origin__' , type_ ) args = [ inner ( a , {} ) for a in getattr ( type_ , '__args__' , []) if a is not type ( None )] if _is_optional ( type_ ): options [ \"allow_none\" ] = True if origin in TYPES : return TYPES [ origin ]( * args , ** options ) if _issubclass_safe ( origin , Enum ): return EnumField ( enum = origin , by_value = True , * args , ** options ) if is_union_type ( type_ ): union_types = [ a for a in getattr ( type_ , '__args__' , []) if a is not type ( None )] union_desc = dict ( zip ( union_types , args )) return _UnionField ( union_desc , cls , field , ** options ) warnings . warn ( f \"Unknown type {type_} at {cls.__name__}.{field.name}: {field.type} \" f \"It's advised to pass the correct marshmallow type to `mm_field`.\" ) return fields . Field ( ** options ) return inner ( type_ , options )","title":"build_type"},{"location":"reference/dataclasses_json/mm/#schema","text":"def schema ( cls , mixin , infer_missing ) View Source def schema ( cls , mixin , infer_missing ) : schema = {} overrides = _user_overrides_or_exts ( cls ) # TODO check the undefined parameters and add the proper schema action # https : // marshmallow . readthedocs . io / en / stable / quickstart . html for field in dc_fields ( cls ) : metadata = ( field . metadata or {} ). get ( 'dataclasses_json' , {} ) metadata = overrides [ field.name ] if metadata . mm_field is not None : schema [ field.name ] = metadata . mm_field else : type_ = field . type options = {} missing_key = 'missing' if infer_missing else 'default' if field . default is not MISSING : options [ missing_key ] = field . default elif field . default_factory is not MISSING : options [ missing_key ] = field . default_factory if options . get ( missing_key , ...) is None : options [ 'allow_none' ] = True if _is_optional ( type_ ) : options . setdefault ( missing_key , None ) options [ 'allow_none' ] = True if len ( type_ . __args__ ) == 2 : # Union [ str, int, None ] is optional too , but it has more than 1 typed field . type_ = type_ . __args__ [ 0 ] if metadata . letter_case is not None : options [ 'data_key' ] = metadata . letter_case ( field . name ) t = build_type ( type_ , options , mixin , field , cls ) # if type ( t ) is not fields . Field : # If we use ` isinstance ` we would return nothing . if field . type != typing . Optional [ CatchAllVar ] : schema [ field.name ] = t return schema","title":"schema"},{"location":"reference/dataclasses_json/mm/#classes","text":"","title":"Classes"},{"location":"reference/dataclasses_json/mm/#schemaf","text":"class SchemaF ( * args , ** kwargs ) Lift Schema into a type constructor View Source class SchemaF ( Schema , typing . Generic [ A ] ) : \"\"\"Lift Schema into a type constructor\"\"\" def __init__ ( self , * args , ** kwargs ) : \"\"\" Raises exception because this class should not be inherited. This class is helper only. \"\"\" super (). __init__ ( * args , ** kwargs ) raise NotImplementedError () @typing . overload def dump ( self , obj : typing . List [ A ] , many : bool = None ) -> typing . List [ TEncoded ] : # type : ignore # mm has the wrong return type annotation ( dict ) so we can ignore the mypy error pass @typing . overload def dump ( self , obj : A , many : bool = None ) -> TEncoded : pass def dump ( self , obj : TOneOrMulti , many : bool = None ) -> TOneOrMultiEncoded : pass @typing . overload def dumps ( self , obj : typing . List [ A ] , many : bool = None , * args , ** kwargs ) -> str : pass @typing . overload def dumps ( self , obj : A , many : bool = None , * args , ** kwargs ) -> str : pass def dumps ( self , obj : TOneOrMulti , many : bool = None , * args , ** kwargs ) -> str : pass @typing . overload # type : ignore def load ( self , data : typing . List [ TEncoded ] , many : bool = True , partial : bool = None , unknown : str = None ) -> \\ typing . List [ A ] : # ignore the mypy error of the decorator because mm does not define lists as an allowed input type pass @typing . overload def load ( self , data : TEncoded , many : None = None , partial : bool = None , unknown : str = None ) -> A : pass def load ( self , data : TOneOrMultiEncoded , many : bool = None , partial : bool = None , unknown : str = None ) -> TOneOrMulti : pass @typing . overload # type : ignore def loads ( self , json_data : JsonData , # type : ignore many : bool = True , partial : bool = None , unknown : str = None , ** kwargs ) -> typing . List [ A ] : # ignore the mypy error of the decorator because mm does not define bytes as correct input data # mm has the wrong return type annotation ( dict ) so we can ignore the mypy error # for the return type overlap pass @typing . overload def loads ( self , json_data : JsonData , many : None = None , partial : bool = None , unknown : str = None , ** kwargs ) -> A : pass def loads ( self , json_data : JsonData , many : bool = None , partial : bool = None , unknown : str = None , ** kwargs ) -> TOneOrMulti : pass","title":"SchemaF"},{"location":"reference/dataclasses_json/mm/#ancestors-in-mro","text":"marshmallow.schema.Schema marshmallow.base.SchemaABC typing.Generic","title":"Ancestors (in MRO)"},{"location":"reference/dataclasses_json/mm/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages opts","title":"Class variables"},{"location":"reference/dataclasses_json/mm/#static-methods","text":"","title":"Static methods"},{"location":"reference/dataclasses_json/mm/#from_dict","text":"def from_dict ( fields : Dict [ str , Union [ marshmallow . fields . Field , type ]], * , name : str = 'GeneratedSchema' ) -> type Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 View Source @classmethod def from_dict ( cls , fields : typing . Dict [ str , typing . Union [ ma_fields . Field , type ]], * , name : str = \"GeneratedSchema\" ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/dataclasses_json/mm/#instance-variables","text":"dict_class set_class","title":"Instance variables"},{"location":"reference/dataclasses_json/mm/#methods","text":"","title":"Methods"},{"location":"reference/dataclasses_json/mm/#dump","text":"def dump ( self , obj : Union [ List [ ~ A ], ~ A ], many : bool = None ) -> Union [ List [ Dict [ str , Any ]], Dict [ str , Any ]] Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize obj as a collection. If None , the value for self.many is used. :return: A dict of serialized data :rtype: dict .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : TOneOrMulti , many : bool = None ) -> TOneOrMultiEncoded : pass","title":"dump"},{"location":"reference/dataclasses_json/mm/#dumps","text":"def dumps ( self , obj : Union [ List [ ~ A ], ~ A ], many : bool = None , * args , ** kwargs ) -> str Same as :meth: dump , except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize obj as a collection. If None , the value for self.many is used. :return: A json string :rtype: str .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : TOneOrMulti , many : bool = None , * args , ** kwargs ) -> str : pass","title":"dumps"},{"location":"reference/dataclasses_json/mm/#get_attribute","text":"def get_attribute ( self , obj : Any , attr : str , default : Any ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ): \"\"\"Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\"\" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/dataclasses_json/mm/#handle_error","text":"def handle_error ( self , error : marshmallow . exceptions . ValidationError , data : Any , * , many : bool , ** kwargs ) Custom error handler function for the schema. :param error: The ValidationError raised during (de)serialization. :param data: The original input data. :param many: Value of many on dump or load. :param partial: Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ): \"\"\"Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\"\" pass","title":"handle_error"},{"location":"reference/dataclasses_json/mm/#load","text":"def load ( self , data : Union [ List [ Dict [ str , Any ]], Dict [ str , Any ]], many : bool = None , partial : bool = None , unknown : str = None ) -> Union [ List [ ~ A ], ~ A ] Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize data as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : TOneOrMultiEncoded , many : bool = None , partial : bool = None , unknown : str = None ) -> TOneOrMulti : pass","title":"load"},{"location":"reference/dataclasses_json/mm/#loads","text":"def loads ( self , json_data : Union [ str , bytes , bytearray ], many : bool = None , partial : bool = None , unknown : str = None , ** kwargs ) -> Union [ List [ ~ A ], ~ A ] Same as :meth: load , except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize obj as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : JsonData , many : bool = None , partial : bool = None , unknown : str = None , ** kwargs ) -> TOneOrMulti : pass","title":"loads"},{"location":"reference/dataclasses_json/mm/#on_bind_field","text":"def on_bind_field ( self , field_name : str , field_obj : marshmallow . fields . Field ) -> None Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \"\"\"Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\"\" return None","title":"on_bind_field"},{"location":"reference/dataclasses_json/mm/#validate","text":"def validate ( self , data : Mapping , * , many : bool = None , partial : Union [ bool , Sequence [ str ], Set [ str ]] = None ) -> Dict [ str , List [ str ]] Validate data against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate data as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : typing . Mapping , * , many : bool = None , partial : typing . Union [ bool , types . StrSequenceOrSet ] = None ) -> typing . Dict [ str , typing . List [ str ]]: \"\"\"Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\"\" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]], exc . messages ) return {}","title":"validate"},{"location":"reference/dataclasses_json/stringcase/","text":"Module dataclasses_json.stringcase View Source # The MIT License ( MIT ) # # Copyright ( c ) 2015 Taka Okunishi # # Permission is hereby granted , free of charge , to any person obtaining a copy # of this software and associated documentation files ( the \"Software\" ), to deal # in the Software without restriction , including without limitation the rights # to use , copy , modify , merge , publish , distribute , sublicense , and / or sell # copies of the Software , and to permit persons to whom the Software is # furnished to do so , subject to the following conditions : # # The above copyright notice and this permission notice shall be included in # all copies or substantial portions of the Software . # # THE SOFTWARE IS PROVIDED \"AS IS\" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR # IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER # LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE # SOFTWARE . # # Copyright \u00a9 2015 - 2018 Taka Okunishi < okunishinishi @gmail . com > . # Copyright \u00a9 2020 Louis - Philippe V\u00e9ronneau < pollo @debian . org > import re def uplowcase ( string , case ) : \"\"\"Convert string into upper or lower case. Args: string: String to convert. Returns: string: Uppercase or lowercase case string. \"\"\" if case == 'up' : return str ( string ). upper () elif case == 'low' : return str ( string ). lower () def capitalcase ( string ) : \"\"\"Convert string into capital case. First letters will be uppercase. Args: string: String to convert. Returns: string: Capital case string. \"\"\" string = str ( string ) if not string : return string return uplowcase ( string [ 0 ] , 'up' ) + string [ 1: ] def camelcase ( string ) : \"\"\" Convert string into camel case. Args: string: String to convert. Returns: string: Camel case string. \"\"\" string = re . sub ( r \"^[\\-_\\.]\" , '' , str ( string )) if not string : return string return ( uplowcase ( string [ 0 ] , 'low' ) + re . sub ( r \"[\\-_\\.\\s]([a-z])\" , lambda matched : uplowcase ( matched . group ( 1 ), 'up' ), string [ 1: ] )) def snakecase ( string ) : \"\"\"Convert string into snake case. Join punctuation with underscore Args: string: String to convert. Returns: string: Snake cased string. \"\"\" string = re . sub ( r \"[\\-\\.\\s]\" , '_' , str ( string )) if not string : return string return ( uplowcase ( string [ 0 ] , 'low' ) + re . sub ( r \"[A-Z]\" , lambda matched : '_' + uplowcase ( matched . group ( 0 ), 'low' ), string [ 1: ] )) def spinalcase ( string ) : \"\"\"Convert string into spinal case. Join punctuation with hyphen. Args: string: String to convert. Returns: string: Spinal cased string. \"\"\" return re . sub ( r \"_\" , \"-\" , snakecase ( string )) def pascalcase ( string ) : \"\"\"Convert string into pascal case. Args: string: String to convert. Returns: string: Pascal case string. \"\"\" return capitalcase ( camelcase ( string )) Functions camelcase def camelcase ( string ) Convert string into camel case. Args: string: String to convert. Returns: string: Camel case string. View Source def camelcase ( string ): \"\"\" Convert string into camel case. Args: string: String to convert. Returns: string: Camel case string. \"\"\" string = re . sub ( r \"^[\\-_\\.]\" , '' , str ( string )) if not string : return string return ( uplowcase ( string [ 0 ], 'low' ) + re . sub ( r \"[\\-_\\.\\s]([a-z])\" , lambda matched : uplowcase ( matched . group ( 1 ), 'up' ), string [ 1 :])) capitalcase def capitalcase ( string ) Convert string into capital case. First letters will be uppercase. Args: string: String to convert. Returns: string: Capital case string. View Source def capitalcase ( string ): \"\"\"Convert string into capital case. First letters will be uppercase. Args: string: String to convert. Returns: string: Capital case string. \"\"\" string = str ( string ) if not string : return string return uplowcase ( string [ 0 ], 'up' ) + string [ 1 :] pascalcase def pascalcase ( string ) Convert string into pascal case. Args: string: String to convert. Returns: string: Pascal case string. View Source def pascalcase ( string ): \"\"\"Convert string into pascal case. Args: string: String to convert. Returns: string: Pascal case string. \"\"\" return capitalcase ( camelcase ( string )) snakecase def snakecase ( string ) Convert string into snake case. Join punctuation with underscore Args: string: String to convert. Returns: string: Snake cased string. View Source def snakecase ( string ): \"\"\"Convert string into snake case. Join punctuation with underscore Args: string: String to convert. Returns: string: Snake cased string. \"\"\" string = re . sub ( r \"[\\-\\.\\s]\" , '_' , str ( string )) if not string : return string return ( uplowcase ( string [ 0 ], 'low' ) + re . sub ( r \"[A-Z]\" , lambda matched : '_' + uplowcase ( matched . group ( 0 ), 'low' ), string [ 1 :])) spinalcase def spinalcase ( string ) Convert string into spinal case. Join punctuation with hyphen. Args: string: String to convert. Returns: string: Spinal cased string. View Source def spinalcase ( string ): \"\"\"Convert string into spinal case. Join punctuation with hyphen. Args: string: String to convert. Returns: string: Spinal cased string. \"\"\" return re . sub ( r \"_\" , \"-\" , snakecase ( string )) uplowcase def uplowcase ( string , case ) Convert string into upper or lower case. Args: string: String to convert. Returns: string: Uppercase or lowercase case string. View Source def uplowcase ( string , case ): \"\"\"Convert string into upper or lower case. Args: string: String to convert. Returns: string: Uppercase or lowercase case string. \"\"\" if case == 'up' : return str ( string ). upper () elif case == 'low' : return str ( string ). lower ()","title":"Stringcase"},{"location":"reference/dataclasses_json/stringcase/#module-dataclasses_jsonstringcase","text":"View Source # The MIT License ( MIT ) # # Copyright ( c ) 2015 Taka Okunishi # # Permission is hereby granted , free of charge , to any person obtaining a copy # of this software and associated documentation files ( the \"Software\" ), to deal # in the Software without restriction , including without limitation the rights # to use , copy , modify , merge , publish , distribute , sublicense , and / or sell # copies of the Software , and to permit persons to whom the Software is # furnished to do so , subject to the following conditions : # # The above copyright notice and this permission notice shall be included in # all copies or substantial portions of the Software . # # THE SOFTWARE IS PROVIDED \"AS IS\" , WITHOUT WARRANTY OF ANY KIND , EXPRESS OR # IMPLIED , INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY , # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT SHALL THE # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM , DAMAGES OR OTHER # LIABILITY , WHETHER IN AN ACTION OF CONTRACT , TORT OR OTHERWISE , ARISING FROM , # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE # SOFTWARE . # # Copyright \u00a9 2015 - 2018 Taka Okunishi < okunishinishi @gmail . com > . # Copyright \u00a9 2020 Louis - Philippe V\u00e9ronneau < pollo @debian . org > import re def uplowcase ( string , case ) : \"\"\"Convert string into upper or lower case. Args: string: String to convert. Returns: string: Uppercase or lowercase case string. \"\"\" if case == 'up' : return str ( string ). upper () elif case == 'low' : return str ( string ). lower () def capitalcase ( string ) : \"\"\"Convert string into capital case. First letters will be uppercase. Args: string: String to convert. Returns: string: Capital case string. \"\"\" string = str ( string ) if not string : return string return uplowcase ( string [ 0 ] , 'up' ) + string [ 1: ] def camelcase ( string ) : \"\"\" Convert string into camel case. Args: string: String to convert. Returns: string: Camel case string. \"\"\" string = re . sub ( r \"^[\\-_\\.]\" , '' , str ( string )) if not string : return string return ( uplowcase ( string [ 0 ] , 'low' ) + re . sub ( r \"[\\-_\\.\\s]([a-z])\" , lambda matched : uplowcase ( matched . group ( 1 ), 'up' ), string [ 1: ] )) def snakecase ( string ) : \"\"\"Convert string into snake case. Join punctuation with underscore Args: string: String to convert. Returns: string: Snake cased string. \"\"\" string = re . sub ( r \"[\\-\\.\\s]\" , '_' , str ( string )) if not string : return string return ( uplowcase ( string [ 0 ] , 'low' ) + re . sub ( r \"[A-Z]\" , lambda matched : '_' + uplowcase ( matched . group ( 0 ), 'low' ), string [ 1: ] )) def spinalcase ( string ) : \"\"\"Convert string into spinal case. Join punctuation with hyphen. Args: string: String to convert. Returns: string: Spinal cased string. \"\"\" return re . sub ( r \"_\" , \"-\" , snakecase ( string )) def pascalcase ( string ) : \"\"\"Convert string into pascal case. Args: string: String to convert. Returns: string: Pascal case string. \"\"\" return capitalcase ( camelcase ( string ))","title":"Module dataclasses_json.stringcase"},{"location":"reference/dataclasses_json/stringcase/#functions","text":"","title":"Functions"},{"location":"reference/dataclasses_json/stringcase/#camelcase","text":"def camelcase ( string ) Convert string into camel case. Args: string: String to convert. Returns: string: Camel case string. View Source def camelcase ( string ): \"\"\" Convert string into camel case. Args: string: String to convert. Returns: string: Camel case string. \"\"\" string = re . sub ( r \"^[\\-_\\.]\" , '' , str ( string )) if not string : return string return ( uplowcase ( string [ 0 ], 'low' ) + re . sub ( r \"[\\-_\\.\\s]([a-z])\" , lambda matched : uplowcase ( matched . group ( 1 ), 'up' ), string [ 1 :]))","title":"camelcase"},{"location":"reference/dataclasses_json/stringcase/#capitalcase","text":"def capitalcase ( string ) Convert string into capital case. First letters will be uppercase. Args: string: String to convert. Returns: string: Capital case string. View Source def capitalcase ( string ): \"\"\"Convert string into capital case. First letters will be uppercase. Args: string: String to convert. Returns: string: Capital case string. \"\"\" string = str ( string ) if not string : return string return uplowcase ( string [ 0 ], 'up' ) + string [ 1 :]","title":"capitalcase"},{"location":"reference/dataclasses_json/stringcase/#pascalcase","text":"def pascalcase ( string ) Convert string into pascal case. Args: string: String to convert. Returns: string: Pascal case string. View Source def pascalcase ( string ): \"\"\"Convert string into pascal case. Args: string: String to convert. Returns: string: Pascal case string. \"\"\" return capitalcase ( camelcase ( string ))","title":"pascalcase"},{"location":"reference/dataclasses_json/stringcase/#snakecase","text":"def snakecase ( string ) Convert string into snake case. Join punctuation with underscore Args: string: String to convert. Returns: string: Snake cased string. View Source def snakecase ( string ): \"\"\"Convert string into snake case. Join punctuation with underscore Args: string: String to convert. Returns: string: Snake cased string. \"\"\" string = re . sub ( r \"[\\-\\.\\s]\" , '_' , str ( string )) if not string : return string return ( uplowcase ( string [ 0 ], 'low' ) + re . sub ( r \"[A-Z]\" , lambda matched : '_' + uplowcase ( matched . group ( 0 ), 'low' ), string [ 1 :]))","title":"snakecase"},{"location":"reference/dataclasses_json/stringcase/#spinalcase","text":"def spinalcase ( string ) Convert string into spinal case. Join punctuation with hyphen. Args: string: String to convert. Returns: string: Spinal cased string. View Source def spinalcase ( string ): \"\"\"Convert string into spinal case. Join punctuation with hyphen. Args: string: String to convert. Returns: string: Spinal cased string. \"\"\" return re . sub ( r \"_\" , \"-\" , snakecase ( string ))","title":"spinalcase"},{"location":"reference/dataclasses_json/stringcase/#uplowcase","text":"def uplowcase ( string , case ) Convert string into upper or lower case. Args: string: String to convert. Returns: string: Uppercase or lowercase case string. View Source def uplowcase ( string , case ): \"\"\"Convert string into upper or lower case. Args: string: String to convert. Returns: string: Uppercase or lowercase case string. \"\"\" if case == 'up' : return str ( string ). upper () elif case == 'low' : return str ( string ). lower ()","title":"uplowcase"},{"location":"reference/dataclasses_json/undefined/","text":"Module dataclasses_json.undefined View Source import abc import dataclasses import functools import inspect from dataclasses import Field , fields from typing import Any , Callable , Dict , Optional , Tuple from enum import Enum from marshmallow import ValidationError from dataclasses_json.utils import CatchAllVar KnownParameters = Dict [ str , Any ] UnknownParameters = Dict [ str , Any ] class _UndefinedParameterAction ( abc . ABC ): @staticmethod @abc.abstractmethod def handle_from_dict ( cls , kvs : Dict [ Any , Any ]) -> Dict [ str , Any ]: \"\"\" Return the parameters to initialize the class with. \"\"\" pass @staticmethod def handle_to_dict ( obj , kvs : Dict [ Any , Any ]) -> Dict [ Any , Any ]: \"\"\" Return the parameters that will be written to the output dict \"\"\" return kvs @staticmethod def handle_dump ( obj ) -> Dict [ Any , Any ]: \"\"\" Return the parameters that will be added to the schema dump. \"\"\" return {} @staticmethod def create_init ( obj ) -> Callable : return obj . __init__ @staticmethod def _separate_defined_undefined_kvs ( cls , kvs : Dict ) -> \\ Tuple [ KnownParameters , UnknownParameters ]: \"\"\" Returns a 2 dictionaries: defined and undefined parameters \"\"\" class_fields = fields ( cls ) field_names = [ field . name for field in class_fields ] unknown_given_parameters = { k : v for k , v in kvs . items () if k not in field_names } known_given_parameters = { k : v for k , v in kvs . items () if k in field_names } return known_given_parameters , unknown_given_parameters class _RaiseUndefinedParameters ( _UndefinedParameterAction ): \"\"\" This action raises UndefinedParameterError if it encounters an undefined parameter during initialization. \"\"\" @staticmethod def handle_from_dict ( cls , kvs : Dict ) -> Dict [ str , Any ]: known , unknown = \\ _UndefinedParameterAction . _separate_defined_undefined_kvs ( cls = cls , kvs = kvs ) if len ( unknown ) > 0 : raise UndefinedParameterError ( f \"Received undefined initialization arguments {unknown}\" ) return known CatchAll = Optional [ CatchAllVar ] class _IgnoreUndefinedParameters ( _UndefinedParameterAction ): \"\"\" This action does nothing when it encounters undefined parameters. The undefined parameters can not be retrieved after the class has been created. \"\"\" @staticmethod def handle_from_dict ( cls , kvs : Dict ) -> Dict [ str , Any ]: known_given_parameters , _ = \\ _UndefinedParameterAction . _separate_defined_undefined_kvs ( cls = cls , kvs = kvs ) return known_given_parameters @staticmethod def create_init ( obj ) -> Callable : original_init = obj . __init__ init_signature = inspect . signature ( original_init ) @functools.wraps ( obj . __init__ ) def _ignore_init ( self , * args , ** kwargs ): known_kwargs , _ = \\ _CatchAllUndefinedParameters . _separate_defined_undefined_kvs ( obj , kwargs ) num_params_takeable = len ( init_signature . parameters ) - 1 # don't count self num_args_takeable = num_params_takeable - len ( known_kwargs ) args = args [: num_args_takeable ] bound_parameters = init_signature . bind_partial ( self , * args , ** known_kwargs ) bound_parameters . apply_defaults () arguments = bound_parameters . arguments arguments . pop ( \"self\" , None ) final_parameters = \\ _IgnoreUndefinedParameters . handle_from_dict ( obj , arguments ) original_init ( self , ** final_parameters ) return _ignore_init class _CatchAllUndefinedParameters ( _UndefinedParameterAction ): \"\"\" This class allows to add a field of type utils.CatchAll which acts as a dictionary into which all undefined parameters will be written. These parameters are not affected by LetterCase. If no undefined parameters are given, this dictionary will be empty. \"\"\" class _SentinelNoDefault : pass @staticmethod def handle_from_dict ( cls , kvs : Dict ) -> Dict [ str , Any ]: known , unknown = _UndefinedParameterAction \\ . _separate_defined_undefined_kvs ( cls = cls , kvs = kvs ) catch_all_field = _CatchAllUndefinedParameters . _get_catch_all_field ( cls = cls ) if catch_all_field . name in known : already_parsed = isinstance ( known [ catch_all_field . name ], dict ) default_value = _CatchAllUndefinedParameters . _get_default ( catch_all_field = catch_all_field ) received_default = default_value == known [ catch_all_field . name ] value_to_write : Any if received_default and len ( unknown ) == 0 : value_to_write = default_value elif received_default and len ( unknown ) > 0 : value_to_write = unknown elif already_parsed : # Did not receive default value_to_write = known [ catch_all_field . name ] if len ( unknown ) > 0 : value_to_write . update ( unknown ) else : error_message = f \"Received input field with \" \\ f \"same name as catch-all field: \" \\ f \"'{catch_all_field.name}': \" \\ f \"'{known[catch_all_field.name]}'\" raise UndefinedParameterError ( error_message ) else : value_to_write = unknown known [ catch_all_field . name ] = value_to_write return known @staticmethod def _get_default ( catch_all_field : Field ) -> Any : # access to the default factory currently causes # a false-positive mypy error (16. Dec 2019): # https://github.com/python/mypy/issues/6910 # noinspection PyProtectedMember has_default = not isinstance ( catch_all_field . default , dataclasses . _MISSING_TYPE ) # noinspection PyProtectedMember has_default_factory = not isinstance ( catch_all_field . default_factory , # type: ignore dataclasses . _MISSING_TYPE ) default_value = _CatchAllUndefinedParameters . _SentinelNoDefault if has_default : default_value = catch_all_field . default elif has_default_factory : # This might be unwanted if the default factory constructs # something expensive, # because we have to construct it again just for this test default_value = catch_all_field . default_factory () # type: ignore return default_value @staticmethod def handle_to_dict ( obj , kvs : Dict [ Any , Any ]) -> Dict [ Any , Any ]: catch_all_field = \\ _CatchAllUndefinedParameters . _get_catch_all_field ( obj ) undefined_parameters = kvs . pop ( catch_all_field . name ) if isinstance ( undefined_parameters , dict ): kvs . update ( undefined_parameters ) # If desired handle letter case here return kvs @staticmethod def handle_dump ( obj ) -> Dict [ Any , Any ]: catch_all_field = _CatchAllUndefinedParameters . _get_catch_all_field ( cls = obj ) return getattr ( obj , catch_all_field . name ) @staticmethod def create_init ( obj ) -> Callable : original_init = obj . __init__ init_signature = inspect . signature ( original_init ) @functools.wraps ( obj . __init__ ) def _catch_all_init ( self , * args , ** kwargs ): known_kwargs , unknown_kwargs = \\ _CatchAllUndefinedParameters . _separate_defined_undefined_kvs ( obj , kwargs ) num_params_takeable = len ( init_signature . parameters ) - 1 # don't count self if _CatchAllUndefinedParameters . _get_catch_all_field ( obj ) . name not in known_kwargs : num_params_takeable -= 1 num_args_takeable = num_params_takeable - len ( known_kwargs ) args , unknown_args = args [: num_args_takeable ], args [ num_args_takeable :] bound_parameters = init_signature . bind_partial ( self , * args , ** known_kwargs ) unknown_args = { f \"_UNKNOWN{i}\" : v for i , v in enumerate ( unknown_args )} arguments = bound_parameters . arguments arguments . update ( unknown_args ) arguments . update ( unknown_kwargs ) arguments . pop ( \"self\" , None ) final_parameters = _CatchAllUndefinedParameters . handle_from_dict ( obj , arguments ) original_init ( self , ** final_parameters ) return _catch_all_init @staticmethod def _get_catch_all_field ( cls ) -> Field : catch_all_fields = list ( filter ( lambda f : f . type == Optional [ CatchAllVar ], fields ( cls ))) number_of_catch_all_fields = len ( catch_all_fields ) if number_of_catch_all_fields == 0 : raise UndefinedParameterError ( \"No field of type dataclasses_json.CatchAll defined\" ) elif number_of_catch_all_fields > 1 : raise UndefinedParameterError ( f \"Multiple catch-all fields supplied: \" f \"{number_of_catch_all_fields}.\" ) else : return catch_all_fields [ 0 ] class Undefined ( Enum ): \"\"\" Choose the behavior what happens when an undefined parameter is encountered during class initialization. \"\"\" INCLUDE = _CatchAllUndefinedParameters RAISE = _RaiseUndefinedParameters EXCLUDE = _IgnoreUndefinedParameters class UndefinedParameterError ( ValidationError ): \"\"\" Raised when something has gone wrong handling undefined parameters. \"\"\" pass Variables CatchAll KnownParameters UnknownParameters Classes Undefined class Undefined ( / , * args , ** kwargs ) Choose the behavior what happens when an undefined parameter is encountered during class initialization. View Source class Undefined ( Enum ): \"\"\" Choose the behavior what happens when an undefined parameter is encountered during class initialization. \"\"\" INCLUDE = _CatchAllUndefinedParameters RAISE = _RaiseUndefinedParameters EXCLUDE = _IgnoreUndefinedParameters Ancestors (in MRO) enum.Enum Class variables EXCLUDE INCLUDE RAISE name value UndefinedParameterError class UndefinedParameterError ( message : Union [ str , List , Dict ], field_name : str = '_schema' , data : Union [ Mapping [ str , Any ], Iterable [ Mapping [ str , Any ]]] = None , valid_data : Union [ List [ Dict [ str , Any ]], Dict [ str , Any ]] = None , ** kwargs ) Raised when something has gone wrong handling undefined parameters. View Source class UndefinedParameterError ( ValidationError ): \"\"\" Raised when something has gone wrong handling undefined parameters. \"\"\" pass Ancestors (in MRO) marshmallow.exceptions.ValidationError marshmallow.exceptions.MarshmallowError builtins.Exception builtins.BaseException Class variables args Methods normalized_messages def normalized_messages ( self ) View Source def normalized_messages ( self ): if self . field_name == SCHEMA and isinstance ( self . messages , dict ): return self . messages return { self . field_name : self . messages } with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"Undefined"},{"location":"reference/dataclasses_json/undefined/#module-dataclasses_jsonundefined","text":"View Source import abc import dataclasses import functools import inspect from dataclasses import Field , fields from typing import Any , Callable , Dict , Optional , Tuple from enum import Enum from marshmallow import ValidationError from dataclasses_json.utils import CatchAllVar KnownParameters = Dict [ str , Any ] UnknownParameters = Dict [ str , Any ] class _UndefinedParameterAction ( abc . ABC ): @staticmethod @abc.abstractmethod def handle_from_dict ( cls , kvs : Dict [ Any , Any ]) -> Dict [ str , Any ]: \"\"\" Return the parameters to initialize the class with. \"\"\" pass @staticmethod def handle_to_dict ( obj , kvs : Dict [ Any , Any ]) -> Dict [ Any , Any ]: \"\"\" Return the parameters that will be written to the output dict \"\"\" return kvs @staticmethod def handle_dump ( obj ) -> Dict [ Any , Any ]: \"\"\" Return the parameters that will be added to the schema dump. \"\"\" return {} @staticmethod def create_init ( obj ) -> Callable : return obj . __init__ @staticmethod def _separate_defined_undefined_kvs ( cls , kvs : Dict ) -> \\ Tuple [ KnownParameters , UnknownParameters ]: \"\"\" Returns a 2 dictionaries: defined and undefined parameters \"\"\" class_fields = fields ( cls ) field_names = [ field . name for field in class_fields ] unknown_given_parameters = { k : v for k , v in kvs . items () if k not in field_names } known_given_parameters = { k : v for k , v in kvs . items () if k in field_names } return known_given_parameters , unknown_given_parameters class _RaiseUndefinedParameters ( _UndefinedParameterAction ): \"\"\" This action raises UndefinedParameterError if it encounters an undefined parameter during initialization. \"\"\" @staticmethod def handle_from_dict ( cls , kvs : Dict ) -> Dict [ str , Any ]: known , unknown = \\ _UndefinedParameterAction . _separate_defined_undefined_kvs ( cls = cls , kvs = kvs ) if len ( unknown ) > 0 : raise UndefinedParameterError ( f \"Received undefined initialization arguments {unknown}\" ) return known CatchAll = Optional [ CatchAllVar ] class _IgnoreUndefinedParameters ( _UndefinedParameterAction ): \"\"\" This action does nothing when it encounters undefined parameters. The undefined parameters can not be retrieved after the class has been created. \"\"\" @staticmethod def handle_from_dict ( cls , kvs : Dict ) -> Dict [ str , Any ]: known_given_parameters , _ = \\ _UndefinedParameterAction . _separate_defined_undefined_kvs ( cls = cls , kvs = kvs ) return known_given_parameters @staticmethod def create_init ( obj ) -> Callable : original_init = obj . __init__ init_signature = inspect . signature ( original_init ) @functools.wraps ( obj . __init__ ) def _ignore_init ( self , * args , ** kwargs ): known_kwargs , _ = \\ _CatchAllUndefinedParameters . _separate_defined_undefined_kvs ( obj , kwargs ) num_params_takeable = len ( init_signature . parameters ) - 1 # don't count self num_args_takeable = num_params_takeable - len ( known_kwargs ) args = args [: num_args_takeable ] bound_parameters = init_signature . bind_partial ( self , * args , ** known_kwargs ) bound_parameters . apply_defaults () arguments = bound_parameters . arguments arguments . pop ( \"self\" , None ) final_parameters = \\ _IgnoreUndefinedParameters . handle_from_dict ( obj , arguments ) original_init ( self , ** final_parameters ) return _ignore_init class _CatchAllUndefinedParameters ( _UndefinedParameterAction ): \"\"\" This class allows to add a field of type utils.CatchAll which acts as a dictionary into which all undefined parameters will be written. These parameters are not affected by LetterCase. If no undefined parameters are given, this dictionary will be empty. \"\"\" class _SentinelNoDefault : pass @staticmethod def handle_from_dict ( cls , kvs : Dict ) -> Dict [ str , Any ]: known , unknown = _UndefinedParameterAction \\ . _separate_defined_undefined_kvs ( cls = cls , kvs = kvs ) catch_all_field = _CatchAllUndefinedParameters . _get_catch_all_field ( cls = cls ) if catch_all_field . name in known : already_parsed = isinstance ( known [ catch_all_field . name ], dict ) default_value = _CatchAllUndefinedParameters . _get_default ( catch_all_field = catch_all_field ) received_default = default_value == known [ catch_all_field . name ] value_to_write : Any if received_default and len ( unknown ) == 0 : value_to_write = default_value elif received_default and len ( unknown ) > 0 : value_to_write = unknown elif already_parsed : # Did not receive default value_to_write = known [ catch_all_field . name ] if len ( unknown ) > 0 : value_to_write . update ( unknown ) else : error_message = f \"Received input field with \" \\ f \"same name as catch-all field: \" \\ f \"'{catch_all_field.name}': \" \\ f \"'{known[catch_all_field.name]}'\" raise UndefinedParameterError ( error_message ) else : value_to_write = unknown known [ catch_all_field . name ] = value_to_write return known @staticmethod def _get_default ( catch_all_field : Field ) -> Any : # access to the default factory currently causes # a false-positive mypy error (16. Dec 2019): # https://github.com/python/mypy/issues/6910 # noinspection PyProtectedMember has_default = not isinstance ( catch_all_field . default , dataclasses . _MISSING_TYPE ) # noinspection PyProtectedMember has_default_factory = not isinstance ( catch_all_field . default_factory , # type: ignore dataclasses . _MISSING_TYPE ) default_value = _CatchAllUndefinedParameters . _SentinelNoDefault if has_default : default_value = catch_all_field . default elif has_default_factory : # This might be unwanted if the default factory constructs # something expensive, # because we have to construct it again just for this test default_value = catch_all_field . default_factory () # type: ignore return default_value @staticmethod def handle_to_dict ( obj , kvs : Dict [ Any , Any ]) -> Dict [ Any , Any ]: catch_all_field = \\ _CatchAllUndefinedParameters . _get_catch_all_field ( obj ) undefined_parameters = kvs . pop ( catch_all_field . name ) if isinstance ( undefined_parameters , dict ): kvs . update ( undefined_parameters ) # If desired handle letter case here return kvs @staticmethod def handle_dump ( obj ) -> Dict [ Any , Any ]: catch_all_field = _CatchAllUndefinedParameters . _get_catch_all_field ( cls = obj ) return getattr ( obj , catch_all_field . name ) @staticmethod def create_init ( obj ) -> Callable : original_init = obj . __init__ init_signature = inspect . signature ( original_init ) @functools.wraps ( obj . __init__ ) def _catch_all_init ( self , * args , ** kwargs ): known_kwargs , unknown_kwargs = \\ _CatchAllUndefinedParameters . _separate_defined_undefined_kvs ( obj , kwargs ) num_params_takeable = len ( init_signature . parameters ) - 1 # don't count self if _CatchAllUndefinedParameters . _get_catch_all_field ( obj ) . name not in known_kwargs : num_params_takeable -= 1 num_args_takeable = num_params_takeable - len ( known_kwargs ) args , unknown_args = args [: num_args_takeable ], args [ num_args_takeable :] bound_parameters = init_signature . bind_partial ( self , * args , ** known_kwargs ) unknown_args = { f \"_UNKNOWN{i}\" : v for i , v in enumerate ( unknown_args )} arguments = bound_parameters . arguments arguments . update ( unknown_args ) arguments . update ( unknown_kwargs ) arguments . pop ( \"self\" , None ) final_parameters = _CatchAllUndefinedParameters . handle_from_dict ( obj , arguments ) original_init ( self , ** final_parameters ) return _catch_all_init @staticmethod def _get_catch_all_field ( cls ) -> Field : catch_all_fields = list ( filter ( lambda f : f . type == Optional [ CatchAllVar ], fields ( cls ))) number_of_catch_all_fields = len ( catch_all_fields ) if number_of_catch_all_fields == 0 : raise UndefinedParameterError ( \"No field of type dataclasses_json.CatchAll defined\" ) elif number_of_catch_all_fields > 1 : raise UndefinedParameterError ( f \"Multiple catch-all fields supplied: \" f \"{number_of_catch_all_fields}.\" ) else : return catch_all_fields [ 0 ] class Undefined ( Enum ): \"\"\" Choose the behavior what happens when an undefined parameter is encountered during class initialization. \"\"\" INCLUDE = _CatchAllUndefinedParameters RAISE = _RaiseUndefinedParameters EXCLUDE = _IgnoreUndefinedParameters class UndefinedParameterError ( ValidationError ): \"\"\" Raised when something has gone wrong handling undefined parameters. \"\"\" pass","title":"Module dataclasses_json.undefined"},{"location":"reference/dataclasses_json/undefined/#variables","text":"CatchAll KnownParameters UnknownParameters","title":"Variables"},{"location":"reference/dataclasses_json/undefined/#classes","text":"","title":"Classes"},{"location":"reference/dataclasses_json/undefined/#undefined","text":"class Undefined ( / , * args , ** kwargs ) Choose the behavior what happens when an undefined parameter is encountered during class initialization. View Source class Undefined ( Enum ): \"\"\" Choose the behavior what happens when an undefined parameter is encountered during class initialization. \"\"\" INCLUDE = _CatchAllUndefinedParameters RAISE = _RaiseUndefinedParameters EXCLUDE = _IgnoreUndefinedParameters","title":"Undefined"},{"location":"reference/dataclasses_json/undefined/#ancestors-in-mro","text":"enum.Enum","title":"Ancestors (in MRO)"},{"location":"reference/dataclasses_json/undefined/#class-variables","text":"EXCLUDE INCLUDE RAISE name value","title":"Class variables"},{"location":"reference/dataclasses_json/undefined/#undefinedparametererror","text":"class UndefinedParameterError ( message : Union [ str , List , Dict ], field_name : str = '_schema' , data : Union [ Mapping [ str , Any ], Iterable [ Mapping [ str , Any ]]] = None , valid_data : Union [ List [ Dict [ str , Any ]], Dict [ str , Any ]] = None , ** kwargs ) Raised when something has gone wrong handling undefined parameters. View Source class UndefinedParameterError ( ValidationError ): \"\"\" Raised when something has gone wrong handling undefined parameters. \"\"\" pass","title":"UndefinedParameterError"},{"location":"reference/dataclasses_json/undefined/#ancestors-in-mro_1","text":"marshmallow.exceptions.ValidationError marshmallow.exceptions.MarshmallowError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/dataclasses_json/undefined/#class-variables_1","text":"args","title":"Class variables"},{"location":"reference/dataclasses_json/undefined/#methods","text":"","title":"Methods"},{"location":"reference/dataclasses_json/undefined/#normalized_messages","text":"def normalized_messages ( self ) View Source def normalized_messages ( self ): if self . field_name == SCHEMA and isinstance ( self . messages , dict ): return self . messages return { self . field_name : self . messages }","title":"normalized_messages"},{"location":"reference/dataclasses_json/undefined/#with_traceback","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/dataclasses_json/utils/","text":"Module dataclasses_json.utils View Source import inspect import sys from datetime import datetime , timezone from typing import Collection , Mapping , Optional , TypeVar , Any def _get_type_cons ( type_ ): \"\"\"More spaghetti logic for 3.6 vs. 3.7\"\"\" if sys . version_info . minor == 6 : try : cons = type_ . __extra__ except AttributeError : try : cons = type_ . __origin__ except AttributeError : cons = type_ else : cons = type_ if cons is None else cons else : try : cons = type_ . __origin__ if cons is None else cons except AttributeError : cons = type_ else : cons = type_ . __origin__ return cons def _get_type_origin ( type_ ): \"\"\"Some spaghetti logic to accommodate differences between 3.6 and 3.7 in the typing api\"\"\" try : origin = type_ . __origin__ except AttributeError : if sys . version_info . minor == 6 : try : origin = type_ . __extra__ except AttributeError : origin = type_ else : origin = type_ if origin is None else origin else : origin = type_ return origin def _hasargs ( type_ , * args ): try : res = all ( arg in type_ . __args__ for arg in args ) except AttributeError : return False except TypeError : if ( type_ . __args__ is None ): return False else : raise else : return res def _isinstance_safe ( o , t ): try : result = isinstance ( o , t ) except Exception : return False else : return result def _issubclass_safe ( cls , classinfo ): try : return issubclass ( cls , classinfo ) except Exception : return ( _is_new_type_subclass_safe ( cls , classinfo ) if _is_new_type ( cls ) else False ) def _is_new_type_subclass_safe ( cls , classinfo ): super_type = getattr ( cls , \"__supertype__\" , None ) if super_type : return _is_new_type_subclass_safe ( super_type , classinfo ) try : return issubclass ( cls , classinfo ) except Exception : return False def _is_new_type ( type_ ): return inspect . isfunction ( type_ ) and hasattr ( type_ , \"__supertype__\" ) def _is_optional ( type_ ): return ( _issubclass_safe ( type_ , Optional ) or _hasargs ( type_ , type ( None )) or type_ is Any ) def _is_mapping ( type_ ): return _issubclass_safe ( _get_type_origin ( type_ ), Mapping ) def _is_collection ( type_ ): return _issubclass_safe ( _get_type_origin ( type_ ), Collection ) def _is_nonstr_collection ( type_ ): return ( _issubclass_safe ( _get_type_origin ( type_ ), Collection ) and not _issubclass_safe ( type_ , str )) def _timestamp_to_dt_aware ( timestamp : float ): tz = datetime . now ( timezone . utc ) . astimezone () . tzinfo dt = datetime . fromtimestamp ( timestamp , tz = tz ) return dt def _undefined_parameter_action_safe ( cls ): try : if cls . dataclass_json_config is None : return action_enum = cls . dataclass_json_config [ 'undefined' ] except ( AttributeError , KeyError ): return if action_enum is None or action_enum . value is None : return return action_enum def _handle_undefined_parameters_safe ( cls , kvs , usage : str ): \"\"\" Checks if an undefined parameters action is defined and performs the according action. \"\"\" undefined_parameter_action = _undefined_parameter_action_safe ( cls ) usage = usage . lower () if undefined_parameter_action is None : return kvs if usage != \"init\" else cls . __init__ if usage == \"from\" : return undefined_parameter_action . value . handle_from_dict ( cls = cls , kvs = kvs ) elif usage == \"to\" : return undefined_parameter_action . value . handle_to_dict ( obj = cls , kvs = kvs ) elif usage == \"dump\" : return undefined_parameter_action . value . handle_dump ( obj = cls ) elif usage == \"init\" : return undefined_parameter_action . value . create_init ( obj = cls ) else : raise ValueError ( f \"usage must be one of ['to', 'from', 'dump', 'init'], \" f \"but is '{usage}'\" ) # Define a type for the CatchAll field # https://stackoverflow.com/questions/59360567/define-a-custom-type-that-behaves-like-typing-any CatchAllVar = TypeVar ( \"CatchAllVar\" , bound = Mapping ) Variables CatchAllVar","title":"Utils"},{"location":"reference/dataclasses_json/utils/#module-dataclasses_jsonutils","text":"View Source import inspect import sys from datetime import datetime , timezone from typing import Collection , Mapping , Optional , TypeVar , Any def _get_type_cons ( type_ ): \"\"\"More spaghetti logic for 3.6 vs. 3.7\"\"\" if sys . version_info . minor == 6 : try : cons = type_ . __extra__ except AttributeError : try : cons = type_ . __origin__ except AttributeError : cons = type_ else : cons = type_ if cons is None else cons else : try : cons = type_ . __origin__ if cons is None else cons except AttributeError : cons = type_ else : cons = type_ . __origin__ return cons def _get_type_origin ( type_ ): \"\"\"Some spaghetti logic to accommodate differences between 3.6 and 3.7 in the typing api\"\"\" try : origin = type_ . __origin__ except AttributeError : if sys . version_info . minor == 6 : try : origin = type_ . __extra__ except AttributeError : origin = type_ else : origin = type_ if origin is None else origin else : origin = type_ return origin def _hasargs ( type_ , * args ): try : res = all ( arg in type_ . __args__ for arg in args ) except AttributeError : return False except TypeError : if ( type_ . __args__ is None ): return False else : raise else : return res def _isinstance_safe ( o , t ): try : result = isinstance ( o , t ) except Exception : return False else : return result def _issubclass_safe ( cls , classinfo ): try : return issubclass ( cls , classinfo ) except Exception : return ( _is_new_type_subclass_safe ( cls , classinfo ) if _is_new_type ( cls ) else False ) def _is_new_type_subclass_safe ( cls , classinfo ): super_type = getattr ( cls , \"__supertype__\" , None ) if super_type : return _is_new_type_subclass_safe ( super_type , classinfo ) try : return issubclass ( cls , classinfo ) except Exception : return False def _is_new_type ( type_ ): return inspect . isfunction ( type_ ) and hasattr ( type_ , \"__supertype__\" ) def _is_optional ( type_ ): return ( _issubclass_safe ( type_ , Optional ) or _hasargs ( type_ , type ( None )) or type_ is Any ) def _is_mapping ( type_ ): return _issubclass_safe ( _get_type_origin ( type_ ), Mapping ) def _is_collection ( type_ ): return _issubclass_safe ( _get_type_origin ( type_ ), Collection ) def _is_nonstr_collection ( type_ ): return ( _issubclass_safe ( _get_type_origin ( type_ ), Collection ) and not _issubclass_safe ( type_ , str )) def _timestamp_to_dt_aware ( timestamp : float ): tz = datetime . now ( timezone . utc ) . astimezone () . tzinfo dt = datetime . fromtimestamp ( timestamp , tz = tz ) return dt def _undefined_parameter_action_safe ( cls ): try : if cls . dataclass_json_config is None : return action_enum = cls . dataclass_json_config [ 'undefined' ] except ( AttributeError , KeyError ): return if action_enum is None or action_enum . value is None : return return action_enum def _handle_undefined_parameters_safe ( cls , kvs , usage : str ): \"\"\" Checks if an undefined parameters action is defined and performs the according action. \"\"\" undefined_parameter_action = _undefined_parameter_action_safe ( cls ) usage = usage . lower () if undefined_parameter_action is None : return kvs if usage != \"init\" else cls . __init__ if usage == \"from\" : return undefined_parameter_action . value . handle_from_dict ( cls = cls , kvs = kvs ) elif usage == \"to\" : return undefined_parameter_action . value . handle_to_dict ( obj = cls , kvs = kvs ) elif usage == \"dump\" : return undefined_parameter_action . value . handle_dump ( obj = cls ) elif usage == \"init\" : return undefined_parameter_action . value . create_init ( obj = cls ) else : raise ValueError ( f \"usage must be one of ['to', 'from', 'dump', 'init'], \" f \"but is '{usage}'\" ) # Define a type for the CatchAll field # https://stackoverflow.com/questions/59360567/define-a-custom-type-that-behaves-like-typing-any CatchAllVar = TypeVar ( \"CatchAllVar\" , bound = Mapping )","title":"Module dataclasses_json.utils"},{"location":"reference/dataclasses_json/utils/#variables","text":"CatchAllVar","title":"Variables"}]}